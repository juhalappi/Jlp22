!Inpuf ;incl
!Inpuf ;goto
!Inpuf ;return
!Inpuf ;do
!Inpuf ;enddo
!Inpuf ;sum
!Inpuf ;dif
!Inpuf ;pause
!Inpuf ;where
!Inpuf ;if
!Inpuf ;elseif
!Inpuf ;else
!Inpuf ;list
!Inpuf ;now

!Macro seecom
!See \vref{comoptions} for more details. 
!endmacro

!Macro data
! data & N|1- & DATA &	DATA object. Default last DATA defined.
!from&N|1&REAL& First observation used.
!until&N|1&REAL& Last observation used.
!trans&N|1&TRANS& TRANS computed fro each observation
!epilog&N|1&TRANS &TRANS computed after going through data.
!endmacro

!Macro in1 
! in&0|1&Char&Indicates from where the data are read in. If there are no arguments, 
! then the data are in the following input paragraph. If the value is a
!character constant or a character variable, then the source is the file with that name.
!endmacro

!Macro in2 
! in&0|1-&Char&Indicates from where the data are read in. If there are no arguments, 
! then the data are in the following input paragraph. If the values are
!character constants or a character variables, then data are read in from
! files having those names.
!endmacro

!Macro draw 
! x&1&REAL&Variable which is stepped before computing the value of func->.
!xrange&0-4&REAL& Range for the x-variable. If there are now arguments Jlp22 tries to
!find variables var%min and var%max which where computed with stat() with options min->
!and max->. If there is need to define a smaller range for computing the values as wished
! for the x-axes, then  
!endmacro







!Macro trans
! trans &-1 | 1&TRANS&	transformation set which is executed for each observation. If there is a transformation set associated with the data set, those transformations are computed first.
!endmacro

!Macro filter
! filter &-1 | 1&Code& logical or arithmetic statement (nonzero value indicating True) describing which observations will be accepted. trans-> transformations are computed before using filter.
!endmacro

!Macro reject
! reject &-1 | 1&Code& logical or arithmetic statement (nonzero value indicating True) describing which observations will be rejected. trans-> transformations are computed before using reject->.
!endmacro

!Macro figure
! append&N | 0 & & The graph is appended to an existing FIGURE. If the output is does not exist 
! beforehand or it is not a FIGURE, then the figure is (and not error) is generated.
! continue&N|0 & & Often sequentila figures are made using include files. It would be diffuct
! to keep track of the figures if Jlp22 continues the Jlp22 script. Thus the default is that
! after plotting the figure, Jlp22 excutes pause() function. The user can
! give any commands during the pause. Typing <return>, the exceution continues. Typing 'e' or 'end',
! an error is generated, and the control returns to sit> promt. If the function
! contains continue-> option, pause() is not generated.
! xlabel & N | 1&CHAR & Label for x-axes. Default is the name of the x-variable.
! ylabel & N | 1&CHAR & Label for y-axes. Default is the name of the x-variable.
!xrange & N |1-2& REAL&the range for x-axes. gnuplot generates it automatically, but
! sometimes the range used by gnuplot needs to be changed.
!yrange & N |1-2&REAL& the range for y-axes. gnuplot generates it automatically, but
! sometimes the range used by gnuplot needs to be changed.
! color & N | 1 & REAL & The color used. The color indices are put to
! following  predefined REAL variables: ]Black[, ]Red[, ]Green[, ]Blue[,
! ]Cyan[ , ]Violet[, ]Yellow[, ]Orange[.
! show& N | 1 & REAL & show->0 indicates the that the figure is not yet plotted. 
! As the value 0 can be given also as a variable or it can be computed, 
! the same code can produce different showing combinations.
! axes & N | 1 &REAL & Are axes drawn. 
! \begin{itemize}
! \item axes->11 Both axes are drawn. (Default)
! \item axes->10 x- axes is  drawn, y-axes not. 
! \item axes->01 x- axes is  drawn, y-axes not. ~ axes->1.
! \item axes->00 Neiher axes is drawn. ~ axes->0.
! \end{itemize}
! endmacro

!Macro draw
! x & 1 & REAL & The x-variable.  
!xrange & 0 | 2& the range for x-axes. The range can be given with REAL values. If
! no arguments are given, then Jlp22 assumes that REAL objects ]x%min[ and ]x%[max, which
! can be computed from data using stat() funtion with options min-> and max->.
! append&N | 0 & & The graph is appended to an existing FIGURE. If the output is does not exist 
! beforehand or it is not a FIGURE, then the figure is (and not error) is generated.
! continue&N|0 & & Often sequentila figures are made using include files. It would be diffuct
! to keep track of the figures if Jlp22 continues the Jlp22 script. Thus the default is that
! after plotting the figure, Jlp22 excutes pause() function. The user can
! give any commands during the pause. Typing <return>, the exceution continues. Typing 'e' or 'end',
! an error is generated, and the control returns to sit> promt. If the function
! contains continue-> option, pause() is not generated.
! xlabel & N | 1&CHAR & Label for x-axes. Default is the name of the x-variable.
! ylabel & N | 1&CHAR & Label for y-axes. Default is the name of the x-variable.
!yrange & N |1-2& the range for y-axes. gnuplot generates it automatically, but
! sometimes the range used by gnuplot needs to be changed.
! color & N | 1 & REAL & The color used. The color indices are put to
! following  predefined REAL variables: ]Black[, ]Red[, ]Green[, ]Blue[,
! ]Cyan[ , ]Violet[, ]Yellow[, ]Orange[.
! show& N | 1 & REAL & show->0 indicates the that the figure is not yet plotted. 
! As the value 0 can be given also as a variable or it can be computed, 
! the same code can produce different showing combinations.
! endmacro



!Section changes Recent changes



!After renaming the software to Jlp22, this chapter starts to describe changes in new versions.
! The corrections of errors are not described in detail. The first version of Jlp22 contains so many new properties that also old users 
!should look at the manual. All the examples of the manual should now go through using ALL in running
! jexamples.inc.

! Version   . New input programming function ;now() added. This is useful 
!  within trans() or within problem() when ;do() is present.

!Version 5.5. 2023. Bug for treating extremly large matrices containg more elements than is the largest integer*4.
!Bugs in rfcode-> and rchead-> in data() function were corrected.

!Version 30.4. 2023. Errors corrected. More examples for graphics. In rewriting of ther software,
! options are set for individual function occurences while in previous versions
! options were set for each code line. Earlier it was necessary to clear options within each
! function. Now they can be cleared just in one place before entering a new function. Now
! full advantage is taken of the new option structure. It may be that some tricky complications
! may arise.

!Version 26.4. 2023. draw() can now make circles etc. stat() can now compute statistics
! for a function without need to put the function values in the data. classify() merges classes
! with too few observations in a better way.
! Some errors corrected. New yet undocumented functions for stem curve
! analyses, e.g. for bucking purposes. Use of hierarchical data in jlp() was made compatible
! with the use of hierarchical data in other functions. Some not-yet-corrected bugs were
!possibly generated.

!Version 19.3.2023 Function jlp() corrected, in the previous version it was 
!completely out of order.

!Version 18.3 2023 Function partdata() can pick part of data by dropping 
!observations and/or variables. function info() prints current objects and options.
!The checking during the parsing phase whether a function has too many arguments 
! is reactivated. It may cause unwarranted error conditions.
! It is possible to make lists of lists and pick the name of the list element which
! is also a list into the input paragraphs. This is useful when making the same
!analysis for many data objects. The stemcurve() function has new properties which
! can be documented if anyone is interested. Now the function can be used to 
! analyse stem vectors generated with harvesters.

!Version 14.3. 2023 Function exceldata() corrected. A bug corrected in jlpz().
! More user errors noticed before a memory overflow. A bug corrected when space
! for numeric constants had to be increased.

!Version 8.3.2023 Some bugs corrected, e.g. in data() function and one bug in the precompiler.
!Some user errors are reported better. The manual is updated. There is
! now function stemcurve() which defines a stem curve used with linear interpolation.
!This is reported if anyone is interested.

!Version 27.2. 2023 Some bugs corrected, i.e. in jlpz(), and some user errors are detected
! to avoid memory overflow. If values of matrix elements were
!given
!in the input paragraph after matrix(), it was not possible to separate numbers with spaces (even if this was not 
!told in the manual). Now spaces are allowed as separators but input programming is not. If 
!input programming tools are needed, it is easly to add option which makes it possible. ;if();then
!structures in the input programming were not described in the manual, now they are.

! Version 23.2.2023. The most important change is that the data() function is rewritten.
!  Now it is simpler and more easy to maintain. It is not possible to make two DATA objects with
! a single call to data(), but it is not really reasonable to put unit data and schedules data 
! into the same file. There are some other changes which are note yet fully reported. Examples go through
! but there are some not properly tested features. 

!Version 25.1.2023. Factory optimization started. It does not work yet
! but the example shows how it can be used in the future.

!Version 31.12.2022. jlp() solves (again) problems without any constraints. 
!The showdomain-> works also for problems without contraints. The new subroutines needed for this
! will smooth the road to factory optimization.

!Version 30.12.2022 jlp() has now showdomain-> option which defines additional domains for which the sums
!  of x-variables are also computed. This option was already in JLP.
! All sums of x-variables are now stored into variables with names starting with Output%. Sums
! in domains are stored in variables with postfix [domaindefinition], e.g. [site.lt.3].

!In version 28.12. 2022 joindata() which builds schedules data from tree format data has two new options
! which allow combining several data sets faster and it is possible to save memory so that larger
! schedules data fits the memory. Some fine tuning of the preface of the manual.

!In version 27.12. 2022 the main change is the possiblity to handle so large matrices that their
! elements cannot be referred with 4-byte integers. Such matrices are needed for schedules from the whole 
! country. This change did cause a large amount of boring editing.
! There are places which are not put into 8-byte integer mode, and I will update
! these places whenever needed. 
!In the data structures, I have the hidden property to work with single precision matrices and with tree-structure
! data which is not made into the tabular form using joindata() function. I will start to 
! utilize these implicit properties when there is lack of memory even in the 64-bit environment. 
! In this Github publication,
! the release exe-file is not updated.

!Version Dec 20 2022 provides simple data formats for storing schedules so that in the simulation tree only thos
! nodes after branching are stored. See keepopen-> and continue-> options in data(). Function joindata() is
! used to build the schedules from their components. Function splitdata() can be used to split data caontaining whole
! schedules into these new compponent datas. splitdata() can be used to convert data generated with previous simulators
! into this new format. It is recommeneded that a simulator generating data for Jlp22 
!starts to write directly into this new format.

! A bug in Fletchers code was found. When after some pivot steps only residual variables
! are in the basis, the code computed wrong shadow prices, and the objective was getting worse.
! This situation will not happen in ordinary linear programming problems. When hunting the bug, I developed new 
! debugging tools, so I hope that all users would now send problematic
!runs to me.

! Now the variable telling the number of observations in DATA datab is always datab%obs.
!  Similarly the variable
! telling how many children that observation has in the lower level 
! is now always datab%nobsw and it must be the 
! first varaible in the list of variables. If the first variable is %nobsw, then its name is automatically
! changed into the proper form. This new legislation was necessary to keep the new multilevel 
!datas in order.

!Version Dec 20 2022 gives possibility to change fonts in figures.

!endsection

!Section preface0 Preface
!\addcontentsline{toc}{section}{Preface}
! The Jlp22 software is the newest version of J software. Don Shepard told via Fortran Discourse that 
 ! that there is already J programming language. In order to avoid confusion, 
 ! the name of J is now changed 
 ! into Jlp22, the name which shows the inheritance from JLP. The name J was used in everything which  happened
 ! to the software before this point. 
 	! In the current version Jlp22, the beef if still the linear programming in forest management planning.
!	But Jlp22 has so many tools for
! data management and numeric computations,	that also vegetarians can use it.
! Perhaps these tools will be first used for preprocessing  data and postprocessing
!the results in conjuction of linear programming. The random number generators
! provide possibilities to do risk computations related to linear programming within Jlp22.
 
! \subsection*{History of J before Luke}
!\addcontentsline{toc}{subsection}{History of J before Luke}
 
 ! JLP is the linear programming (LP) software I made for the forest planning system Mela
 ! which was created by Markku Siitonen in Finnish Forest Researc Institute  
 !(Metla). Section 'JLP linear programming algorithm' describes the development and key points in the algorithm. 
 !Here only the development is described from the organizational point of view.
 ! JLP was published 1992 (see \href{run:./jlp92.pdf}{jlp92.pdf}) and 
	! Finnish Forest Research Institute (Metla) started to distribute it.
! I wrote most part of it when payed by Academy of Finland.  
 ! NMBU started to use JLP from the beginning in its GAYA software which was then called GAYA-JLP.
 


! I wrote J as a successor for JLP. First version of J,
  ! version 0.9.3 was published in 2004. The beef in J was the same linear programming 
	! algorithm as in JLP. J provided many new possibilities
	! for preprocessing of data and postprocessing of results, and these computations
! can be used  also without LP problems.
	! Even Bergseng from NMBU 
	! started to use J in a premature face and thus he had to tolerate quite much mix-up. The GAYA 
 ! started to use J in the planning system called thereafter GAYA-J. Mela has not
 ! included J as
 ! as the optimizer, but it is possible to pull out simulated schedules from Mela and then
 ! define and solve linear programming problems using J. 

! Simosol started to use J as an 
! optimizer from the beginning. Simosol has privately admitted 
 ! that they are using much J.
!  For some reason Simosol
 ! wants to keep this hidden from the users of their sofware and from the public. 
 ! It would be important for an open source software that 
 ! the users would rise a flag when they use the sofware. 
 ! This would give feedback to the developers 
 ! and would allow communication between users. 
 
 ! J version 2.0 published in 2013 made it possible optimize simultatenously
 ! forestry and transportations to factories
 ! and factory production. 
 ! Reetta Lempinen started to work with me in the factory optimization. 
 ! Reetta has professional
 ! training in programming, while I'm a self-learning amateur.
! Reetta had a clear head to keep complicated data structures I had created in order. 
	! She also maintained the spirit during the black moments. The theory for J with factories was published 
!\href{run:./lappilempinen.pdf}{Lappi and Lempinen 2014}.

	
	! \subsection*{J in Luke}
!\addcontentsline{toc}{subsection}{J in Luke}
		! When working with Reetta, I noticed how terribly dirty the code was. I started to clean the 
	! code.
 ! In 2015 Metla and 
 ! two other institutes were merged into Institute of Natural Resources Finland (Luke). 
 ! When my retirement was approaching, I suggested Luke that J would be published as
 ! an open source software so that I could continue its development after my retirement. 
! The leaders of Luke told that it is a good idea to open the software, and this is so important that
  ! Luke cannot let me take care of the publication but the leaders wanted to publish J
 ! themselves. This started a frustrating and humillating hostile overtake process which lasted six 
 !and half years. Eleven
 ! leaders of Luke were involved,
 ! and none of them was eventually interested to get the software publisehd.
 
 !I retired in February 2017.  Research director Johanna Buchert signed the opening decision 30. 8. 2017.
 ! I was not informed of the decision. Later Luke rejected explicitly any cooperation
 ! in the publication or in the development of 
 ! the software.
 
 !When Lauri Mehtätalo became a professor in Luke, he was able to mediate negotiations between me and Luke.
 ! The co-operation agreement was signed 7.10. 2021, in the 100 years celebration of NFI in  Kings Hall
 ! in the medieval Olavinlinna castle in Savonlinna.
 
 ! I got a
 ! permission to publish the software, and Luke agreed to 
 ! provide  treatment schedules simulated with Mela using NFI data from whole Finland and data
 ! from pulp mills and saw mills. 
 ! Luke should provide me access to CSC supercomputers.  Luke should distribute Jlp22 via Github.  This point
 ! was not necessary as Reetta adviced me how to use Github.
 
 ! I was told in Olavinlinna that there has actually been no disagreement
! between me and Luke in this process.
 ! As I could not accept the interpretation that I had fighted six and half years against wind mills, 
 ! I described in previous versions some details of the process. This kept my bitterness
! alive which was unfortunate for my peace of mind and also because
! I knew well how pathetic old bitter men are. After some recent rounds of opposite argumentation, the research director
! called me in January 12 2023 and admitted that Luke did not handle the opening and publication properly
! and that Luke will improve its procedures. I want now look forward, and I make 
!only two comments.

! First, I think that if a government research institute decides that a sowtware can be
!opened and published, the principal author should have the right to participate in the
!preparation of the formal opening decision and to take care of the publication.

!Second.
! The software contained so much dirty code that it could not be developed without my involvement,
! and barely even maintained. The leaders of Luke did not know this because they were not
! interested to discuss with me anything related to the state, publication or 
! development of the software. I think that an expert organization should
! always consult best experts. 

  
 ! \subsection*{Rewriting the software}
!\addcontentsline{toc}{subsection}{Rewriting the software}
 
 ! Open Jlp22 was published 22.4.2022 in a web-seminar, and it has been distributed in Github since then.
 ! It contained many errors, but I wanted to get the open J started.
 ! After my retirement I have rewritten completely the software, 
 ! the most part after the agreement in 7.10.2021. 
 ! Only the sceleton and innermost loops in the optimization come from the time I worked 
 ! for Metla and Luke. One important change was to put the software into 64-bit which
 ! allows the analysis of big data sets. The following manual tells what Jlp22 can do now.
 ! The factory optimization is under development, and I will be published it later. 
 ! Reetta has been actively testing the software,
 !  in addition to teaching the use of Github and giving encouragement all the time.
 
 
 !\subsection*{Book: Linear and nonlinear programming methods}
 !\addcontentsline{toc}{subsection}{Book: Linear and nonlinear programming methods}
 !I signed in Dec 15 2022 with Chapman \& Hall the author agreement that I will write 
 !a book with title: 'Linear and nonlinear programming methods for joint analysis of forestry 
 ! and factories: Jlp22 approach'.
 
 !The book will be published with Open Access if I pay 16500 Euro when the book is ready.
!  I want it be OA as it is based on an open software. Alongside with the book, there will be a script file so that the readers
! can repeat computations just writing the name of the example, similarly as the users
 ! of Jlp22 can compute the examples in this manual. So I need data which I can utilize for such OA
 ! computations. My current agreement with Luke does not allow such utilizitation of Luke's data. 
 
 
 
 
 ! \subsection*{Acknowledgements}
!\addcontentsline{toc}{subsection}{Acknowledgements}


 
 !I acknowledge the contribution of 
 ! Even Bergseng and Victor Strimbu from NMBU for co-operation in the development of J, Kyle Eyvindson from NMBU/Luke for 
 ! providing me access to CSC supercomputer, Hannu Salminen for co-operation. 
 ! Hannu Hirvel\"a  provided me Mela data, and Pekka Hyv\"onen factory data. 
 !Lauri Meht\"atalo was building with me the links between J and R. 
 !Ron Shepard adviced in Fortran Discourse to make expansion of allocated
 !vectors faster, in addition to advicing to chance the name of J software.
 !I thank Reetta Lempinen for being a loyal colleague for a long time. 
 

 !I thank my grand daughter Ella
!for the permission to use the portrait she drawed for my 70 yr birthday in 2021.

!\vspace{0.5cm}
!Suonenjoki 25.1.2023
!\vspace{0.5cm}
!  Juha Lappi

!endsection


! \subsection*{About the writing style}
!\addcontentsline{toc}{subsection}{About the writing style}
! There are two authors in this manual. In the recent changes, Reetta's role  has been in testing
! and guiding the use of Github. The use of passive expressions would be be too demanding for my
! skills of English. Thus I will write 






!Section intro Introduction
!Jlp22 can be used as is, i.e. using exe files. The User's guide concentrates 
!on using binary files, but some reference is also made to additional possibilities offered
! by the open Jlp22 code.
!endsection

!Section intro1 Using Jlp22 exe files
!Jlp22 is a general program for many different tasks. In one end, Jlp22 is a programming language which
! can be used to program several kind of applications and tasks, starting from computing 1+1, either
!at sit> promt or inside a trasformation object. 
!In the other end, it contains many functions which
! can do several tasks in statistics, plotting figures, 
! deterministic and stochastic simulation and linear optimization. Forest planning with factories
!using jlp() function can take several hours. 
! The general Jlp22 functions and Jlp22 trasformations can be combined in many ways.

! There are several alternatives for doing general mathematical and statistical 
! computations available in Jlp22, most prominent being R. For  users of R, the most interesting
! functions in Jlp22 are evidently the linear programming functions which utilize the the structure
! of typical forest managment planning problems. The forest management planning can now 
!in principle be combined with factories. Just now a completely new version of factory optimization
! is under development, and thus it is not usable. R users can do general data management in R and use 
! Jlp22 only for linear programming. But after learning basics of Jlp22, it may be more 
! straightforward to do also data management in Jlp22. 

! Jlp22 can now be used for general matrix computations. I have included in Jlp22 all matrix functions of 
! Matlab which I found useful in a consulting project. Jlp22 uses gnuplot for making figures. 
! It is straigtforward to extend these graphics functions. Jlp22 can be used an
! interface to gnuplot graphics.  Jlp22 contains many tools to deal with classified data. 

! The current binary versions of Jlp22 are developed using Gfortran Fortran 90 compiler in MSYS2 MINGW 64-bit environment
! under Windows 10. 
! Binary versions are ordinary console applications. It is recommended that Jlp22 is used in command
! prompt window, so that 
! if execution of Jlp22 terminates unexpectedly, the error debugging information remains visible.
! With the debug version the problematic line is indicated.
! See chapter \ref{error} for more information of error handling.


!endsection
 
 !Section intro2 Developing own Jlp22 functions in Fortran
 ! The user's of Jlp22 can utilize the open source of Jlp22 in principally two different ways. 
 ! Either the user can develop new versions of existing Jlp22 functions or the user can can make new functions.
 ! It both cases the user should make new developments using so called own functions, which can 
 ! be independently of the main Jlp22 functions. When modifying an existing Jlp22 function, the user should make a copy of the
 ! function under a different name. Then the old and new versions
! can exist simultaneously in the function
 ! space of Jlp22. It is very easy to add new functions in Jlp22 and even more easy to add new options.
 
 !When deloping a new methods in Jlp22, it is possible to first use the Jlp22 
 !script language to make developments.
 !Then the user can make an own function where the method is written in Fortran to make the method faster.
 ! When writing new methods in Fortran, the user can concentrate on essential parts of the method, and utilize 
 ! the standard data management services provided by Jlp22.
 
 
! See Jlp22Development.docx to start develop the software or to add
! own functions. This guide is not up to data, so all who are willing to start development shoud 
!caotact first juha.lappi.sjk@gmail.com. The development package contains, in addition to source code for
! the standard Jlp22 software, program Jmanual
! which can be used to generate Latex code for the manual and the include file for
!examples.   The precompiler Jpre  writes necessary Fortran statements to access all global
! Jlp22 data structures, makes indentations and checks if-then and do strutures and gives
! better error messages for them than Gfortran.
 !endsection
 
 
 
 
 


! The development of new Jlp22 applications is made easier with special input programming. Input 
! programming can generate efficiently several Jlp22 code lines with few lines so that any part of
! object names can be have indices. Jlp22 scripts can be read from include files which can contain
! sections, so that all code of a project can be stored in one file. Different sections can
! be executed by just writing the name of the section at sit> prompt.
!
!The code development is easy using efficient debugging tools. The output of a Jlp22 function is printed
! if the line ends with ';' or ';;'. After the code development, the printing can be put off without 
! changing the code by telling with ]Printresult[ variable whether ';' or ';;' or - results 
! are printed. During pause() the user can do any computations and print objects and
! then either continue or interrupt the process. With ]Debugconsole[ variable the user can
! tell whether pause() is generated after each command line read from an include file. With
!]Debugcode[ the user can tell wether pause() is generated after each line when Jlp22 interprets
! code made by the parser and which is packed into a transformation object.

!Jlp22 is now efficient program to do many kind matrix computations. After retirement I sold a client 
!an algorithm which I dad developed using J. I submitted the algorith using Matlab code, 
! and thus learned Matlab. Then I implemented all Matlab properties I found useful. 
! all arithemetical, trigonometric and logical funtions cand operate both on scalars and matrices.
! Some useful extensios to normal computation rules were addewd. Matrices can be made
! from submatrices, submatrices can be extracted from matrices and replaced by other
! matrices. 
!
!The list object is used to transimit and acces object lists. If the list elements are 
! objects called REAL variables, the list can be used in matrix computaions 
! in the same way as column vectors.
!
! The input programming  has the following functions and capabilities.
!\begin{itemize}
!\item ;incl(file,form->) include code from file starting from a label, e.g. as ;ad1;
!\item ;do(i,ia1,ia2,step) generates input records in a loop
!\item ;if();then \\ !includes conditionally code
!\item objstart"i"end  ! replaces i in the text with the integer value of i. Combined with ;do()
! this provides possibilites to generate large numer of lines using only some linse
! ;goto()  ! code is obtained from a different place of an include file.
! ;elseif();then \\
! ;else \\
! ;endif
!\item ;now() Executes immediamently the code within parenthesis. This is useful 
!  within trans() or within problem() when ;do() is present. 
!\end{itemize}

! Jlp22 functions can have arguments and options. Options are used to trasnmit optional arguments
! to a function. Options are expressed as option->. If the option does not refer to a single object then
! the value of the option must be put into parentrhesi.In some cases the prence or absence of an argument passes an logical
! argument into a function. There tow groups of options, ordinaryy options and code options.
! Ordinalry options treansmit either object names or numeric values into a function.
! code options contain a short peice of code which is computed several times form within the function.
! E.g. func->sin(x) can tells the draw() function waht is the function to be drawn. If 
! computation of the codeoption rquires several lines, then thes lines can be 
! packed into a transformation object. E.g. if ]tr] computes the value of ]res[ REAL object, 
! then the func->tr(]res[) is used to tell how the function value is computed.




!Section special Special implicit functions
!The special functions are such that the parser uses these functions for special operations.
!Only list2() is function which also the user can use, but the parser is
! is using it implicitly. 
!endsection
!
!Section setoption setoption(): set option on
! When a function has an option then the parser generates first code
! setoption(...) where the arguments of the option are interpred in the similar way as
! arguments of all functions. Then the parser genarates the code for
! setoption() function in a special way. 
!endsection

!Section getelem0 getelem(): extracting information from an object
! The origin of this function is the function which was used in previous versions
!to take an matrix element, which explains the name. Now it is used to extract 
! also submatrices (e.g. a(1,-3,All)) , or to get value of an regression 
! function or to compute
!a transformation and then take argument object as the result. E.g. if ]tr[ is a transformation
!then the result of  ]tr[(]a[) is object ]a[ after calling ]tr[.
!endheader
!Note If someone starts to use the own function property of the open source J, she/he
! probably would like to get the possibility to extract information from her/his object types
! also. To implement this property requires some co-operation from my side.
!endnote
!endsection

!Section setelem setelem(): Putting something  into an object.
! The origin of this function is the function which was used in previous versions
!to set an matrix element, which explains the name. Now it is used to replace values 
!of submatrices when submatrix expression is on the
! output side (e.g. a(1,-3,All)=..). 
!endheader
!Note If someone starts to use the own function property of the open source J, she/he
! probably would like to get the possibility to put information into from her/his object types
! also. To implement this property requires some co-operation from my side.
!endnote
!Note In effect the getelem() and setelem() functions are excuted in the same
! getelem() subroutine, because bot functions can utilize the same code.
!endnote
!endsection

!Section list20 list2()
!The interpreted utilizes this to separate when spearating output and input objects.
! See Section \ref{list2} hw user can use this function
!endsection 



!Section setcode setcodeopt(): Initialization of a code option
! This function initializes an code option for a function which has the option. 
!endsection

!Section objects Functions for handling objects
!The following functions can handle objects.
!endsection

!Section deleteuu delete\_omika(): delete an object
! delete_o(]Obj[) deallocates all the allocated components of the object and
! makes the object a REAL variable (it is not possible to remove object names).
! An charcter constant cannot be deleted. If a character variable (i.e. an oobject pointing
! to a character constant) is associated with an open file, it cannot be
!deleted before closing the file.
!endheader
!Note In previous versions files and objects were deleted with the same delete() function
!which was potentially dangerous.
!endnote
!endsection

!Section existo exist_o(): does an object exist
! looks whether an object with the name given in
! the character constant  argument exists. 
!endheader
!Note In the previous versions of Jlp22 same function was used for files and objects.
!endnote
!endsection

!Section existf exist_f(): does a file exist
! looks whether a file with the name given in
! the character constant  argument exists. 
!endheader
!Note In the previous versions of Jlp22 same function was used for files and objects.
!endnote
!endsection

!Section name name(): writes the name of an object
! The argument gives the index of the object. This function
! may useful if J prints in problem cases the object indices.
!endsection


!


!Section sekava pupua
! Jlp22 is a general program for doing different tasks in data analysis, matrix computations,
! simulation and optimization. It is intended to be used mainly in different forestry related
! applications. It has superseded the previous linear programming software JLP (Lappi 1992).
! Most users are interested in applying Jlp22 in linear programming problems of forest management
! planning. Linear programming functions and examples are described in chapter 11. Jlp22 version
! 2.0 is introducing factory problems where transportation costs and factory capacities can be
! taken into account. Factory problems are also described in chapter 11. Shortest route to linear
! programming problems is to read basics of command generation programming from chapter
! 3.2, at least ;incl() function from chapter 3.2.3. Forestry LP-problem requires also use of
! data() function (chapter 9.1) and usually also linkdata() function (chapter 9.3). LPproblems are defined with problem() function (chapter 11.5) and the problems are solved
! with jlp() function (chapter 11.7). After version 2.1 it is possible to solve large ordinary linear
! programming problems without problem() function using zmatrix-> option in jlp()
! function. To access the weights of optimal treatment schedules and to get them into files
! requires use of Jlp22-transformations (chapter 4.) inquiry functions (chapter 11.11), IO-functions
! (chapter 8), loops (chapter 7.2). An example is given in chapter 11.
!
! Jlp22 is operated using text command lines, but it contains tools which make this kind of operation
! mode more efficient, e.g. input can be included from files so that a part of the input lines is
! reinterpreted, input lines can be generated using loop constructs etc. These properties are
! called here as input programming.
!endsection

!Section compo The main components of Jlp22 program 
! The structure of Jlp22 program
!Latex
! \begin{itemize}
! \item Input programming which generates text input for the parser (subroutine
! j\_getinput). Jlp22 commands are obtained:
!\begin{itemize}
!\item from sit> prompt
! \item form possibly nested include files
!\end{itemize}
! \item parser which generates from text lines integer vectors containing function indices,
! option indices and object indices (subroutine j\_interpret). 
!\item Function driver which executes the code in the interpreted integer vector
! (subroutine dotrans). The function driver is using:
!\begin{itemize}
! \item Jlp22 functions which operate on arguments which are determined either as formal arguments or
! via options.
! \item Jlp22 objects
! \item Global variables and matrices
! \item Utility subroutines
!\end{itemize}


! \end{itemize}
!endlatex
 ! A user of Jlp22 needs only input programming and Jlp22 functions, but understanding of 
 ! the other properties may help to understand waht is going on in a Jlp22 session.
!endsection

!Section git  Loading Jlp22 from Github 
! The Github ditribution was made under the guidance of Reetta Lempinen. This section describes the 
! folders of the Github distribution.
!endsection

!Section gitpack Git package
!The Jlp22  package can be loaded by pressing load zip button under the green
! code button in the right side of the page Github.com/juhalappi/Jlp22.  The package
!contains the following files.

!\begin{itemize}
!\item LICENSE the license file
!\item README.m readme file
!\end{itemize}

!The package contains following folders:

!\begin{itemize}


!\item \textbf{JR}  \hspace{0.2cm} using Jlp22 from R, courtesy of Lauri Meht\"atalo.

!\begin{itemize}
!\item j.par \hspace{0.2cm}default include file for starting Jlp22. It contains also a LP
! problem and its solution. 
!\item JR\_0.0.tar.gz \hspace{0.2cm} File needed to use Fortran subroutines in R
!\item cdat.txt
!\item xdat.txt
!\end{itemize}

!\item \textbf{Jbin}\hspace{0.2cm} binary .exe files and dll files
!\begin{itemize}
! \item jlp22.exe \hspace{0.2cm} Debug version of Jlp22.
!\item jlp22r.exe \hspace{0.2cm} Release version of Jlp22. If the release version crashes,
!    use the debug version to get more information of the cause.
! \item jmanual.exe \hspace{0.2cm} makes the latex code file  \href{run:./jmanual.tex}{jmanual.tex} and
!    the example file \href{run:./jexamples.inc}{jexamples.inc}.
! \item jpre.exe \hspace{0.2cm} the precompiler which generates the code 
!   for accessing variables in modules, makes indentations and gives better error messages
!   for mixed do-loops and if-then structures than Gfortran.
! \item dll:\hspace{0.2cm} libgcc\_s\_seh-1.dll, libgfortran-5.dll, libquadmath-0.dll and
!  libwinpthread-1.dll which must be available in the path. e.g., in the same folder as the exe
!\end{itemize}

!\item \textbf{Jdocdemo} \hspace{0.2cm}documents and include file for running examples from User's guide
!\begin{itemize}
! \item Jlp22.pdf \hspace{0.2cm} This user's guide made with Latex using Overleaf \url{http://www.overleaf.com}. 

! \item \href{run:./jexamples.inc }{jexamples.inc} \hspace{0.2cm}include file which can be used to run all examples in the manual
!   and which is generated with jmanual.exe
!\item \href{run:./cdat.txt}{cdat.txt} \hspace{0.2cm}example unit data file for small jlp() example in jexample.inc. 
!\item xdat.txt\hspace{0.2cm}example schedule file for small jlp() example
! \item \href{run:./jlp92.pdf}{jlp92.pdf} \hspace{0.2cm}Manual of old JLP which explains the theory behind the jlp algorithm
! \item \href{run:./lappilempinen.pdf}{lappilempinen.pdf} \hspace{0.2cm} Paper explaining the theory behing factory optimization.
! \item \href{run:./hyvonenetal2019.pdf}{hyvonenetal2019.pdf} \hspace{0.2cm} A paper utilizing the factory optimization.
! \item \href{run:./JLp22development.docx} {Jlp22development.docx} \hspace{0.2cm} not up-to-date manual for developers
!\item \href{run:./fletcher.pdf}{fletcher.pdf} The theory behind the subroutines of Fletcher
!\end{itemize}

!\item \textbf{Jmanual} \hspace{0.2cm} Source files for making Latex code for 
! the manual and the include file for running examples
!\begin{itemize}
! \item jmanual.f90 \hspace{0.2cm}source for making the Latex code and jexamples.inc
! \item jmanual.tex \hspace{0.2cm}Latex code generated with jmanual.exe
! \item jsections.txt \hspace{0.2cm}describes manual sections not in source files
! \item jsections2.txt \hspace{0.2cm}tells in what order sections found in jsections.txt 
!  and source files are put into the manual and what is the level of the sections
! \item main.tex  \hspace{0.2cm}Preample code containing Latex definitions
! \item Makefile\_debug \hspace{0.2cm}Makefile for making jmanual.exe
!\end{itemize}

!\item \textbf{Source} \hspace{0.2cm} source code before precompilation
!\begin{itemize}
!\item fletcherd.for \hspace{0.2cm}Fletchers subroutines turned into double precision
! \item j.f90 \hspace{0.2cm}code for Jlp22 functions
! \item jlp.f90 \hspace{0.2cm}code for linear programming
! \item j.main \hspace{0.2cm}main prorgam for calling Jlp22 when used as is, if Jlp22 is used as 
!a subroutine then this must be made a subroutine
! \item jmodules.f90 \hspace{0.2cm}data structure definitions 
! \item jutilities.f90 \hspace{0.2cm}subroutines for handling objects etc.
! \item jsysdep\_gfortran.f90 \hspace{0.2cm}system dependent routines
! \item matsub.f \hspace{0.2cm}subroutines obtained from other sources, e.g. from Netlib
! \item other subroutines for setting up users own  functions
!\end{itemize}

!\item\textbf{Source2} \hspace{0.2cm} source code files after precompilation
! in addition to files in Source (such files which are not precompiled are put in both folders)
!\begin{itemize}
! \item makefile\_debug \hspace{0.2cm}makefile for making debug version Jlp22.exe
! \item makefile\_release\hspace{0.2cm} makefile for making release version Jlp22r.exe
!\end{itemize}


!\end{itemize}
 
!endsection

!Section gitload Loading the package

! The installation is here described from the viewpoint of an user 
!who just want to use Jlp22, not develop it (yet).

! The load zip button loads file Jlp22-master.zip. Copy this file into a proper folder.
! Let it be Jgit. Clicking the Jlp22-master.zip icon shows folder Jlp22-master in 
! 7Zip (if this is installed). Clicking unpack 7zip unpacks it to the folder Jgit. 
! Too many folder levels are avoided, if everyhing in folder Jlp22-master 
!is copied directly in
 ! folder Jgit.
 
 ! The jlp22.exe is the debug version of Jlp22 and Jlp22r is the release version.
! The debug version should be 
 ! used still used to set up a project. When everythings seems to work, the user
 ! can try the release version in production runs where the time is of some concern.
  ! Let us assume that the working folder is jtest.
!endsection
 
 !Section start Install
 !This section tells how to install Jlp22, gnuplot and Rscript from Jlp22
! so that the user can start
!  running the examples in file jexamples.inc.
 !endsection
 
 !Section install Install
!endsection

!Section installjlp22 Install Jlp22
 ! After loading Jlp22 from the github.com/juhalappi/Jlp22, the folders of the exe files must be
!  put into the environmental variable PATH. In my computer the PATH contains line C:\textbackslash jlp22
! An ordinary user may use Jlp22 and Jlp22r from the folder 
! Jgit\textbackslash Jlp22bin.
!endsection

!Section installgnuplot Install gnuplot
	! Let us then install gnuplot. Go to page \url{http://gnuplot.info}, and select there download,
	! and in the download page select green 'download latest version', which loads 
	! 'gp543-min64-mingw.exe' (or similar), and if you let it install with usual yes-next procedures
	! gnuplot is installed  in folder c:\textbackslash program files\textbackslash gnuplot
!which should be placed into the environmental variable Path. 
!endsection

!When adding new lines to the path, it is necessary to accept changes with two 'OK'.
!After editing PATH have effect only after restarting the computer.

!Section installrscript Install Rscript 

	!If you plan to run R scripts from Jlp22, Rscript program mus be installed 
	! and the folder must be put into the PATH. In my computer the folder is
!	C:\textbackslash Program Files\textbackslash R\textbackslash R-4.1.2\textbackslash bin
! endsection

!Section afterinstall After install restart
!After editing the environmental varaible Path, the computer mus be restarted.
!endsection
	
	! Section runex Running examples
	
	! If you plan to edit the example file, copy jexamples.inc and jlp22.pdf  from jdocdemo folder into the Jtest folder. 
 ! It is not wise to start 
 ! working in the Jdocdemo folder, because if you load a new version of Jlp22 in a similar way into Jgit folder
 ! and allow the computer replace existing folders with the same name,
 ! you would loose the work done in Jgit folder.
 
 ! Open the command prompt and move to the directory 'jtest' by 'cd' commands. 
 ! It is possible to use Jlp22 also directly, but its necessary to use Jlp22 through the command prompt 
	! at this testing phase, because then, if Jlp22 crashes, the error messages do not disappear.
	! In first time, you may want to change 
	! the colors etc of the commant prompt (color may take effect only after
	! closing command prompt and reopening it). It may be reasonable to tick all editing
	! properties under the properties button of the command prompt.
 
 ! If you would like that when starting Jlp22 in this folder, Jlp22 immediately starts with examples,
 ! make file j.par to folder jtest and write
  ! to it
	
	! ;incl(jexamples.inc)
 
 ! It is possible to write to the first line of j.par 
 
 ! *3000
 
 ! which would mean that Jlp22 would generate intially 3000 named objects.
 
 
	! Then start Jlp22 by giving command Jlp22 at the command prompt.
	! If you have not done j.par file, write at the sit> prompt:  ;incl(jexamples.inc).
	! Alternatively you can diretly start in the jexamples.inc by launching Jlp22 by\\
!  Jlp22 jexamples.inc	
	
	! Jlp22 will then print all shortcuts available. You can run examples one by one by giving example shortcuts
! individually, or you can run all examples by shortcut ALL. If you give shortcut ALL, Jlp22 asks whether
! a ;pause is generated after each example ('pause after each example(1/0)>'). 
! Even if pause() is not generated after each example, it is generated after each plot. 
! This can be prevented by pressing <return> when Jlp22 asks value for fpause. Examples in the ALL section can anyhow be started
! at any point by putting label ';current:' to any point after label ;ALL: and giving shortcut
! 'current'. This is also handy when examples have errors which break the execution. If the errors are made 
! intentionally to demonstrate error situations, the interruption of excution after these intentional errors are
! prevented so that the jexamples.inc have command Continue=1 before the intentional error. Theafter the normal
! error handling is put on by command Continue=0.

! It is useful to keep the manual open and follow simultaneously the manual and the execution of examples.
	
 

!endsection

!
 !Section objintro Jlp22 objects
 ! Jlp22 objects have a simple yet efficient structure. Each object is associatd with two integer vectors, one single precision vector, one double precision vector, 
 ! one vector of characters and one vector of text lines. All vectors are allocated dynamically.
 ! There are several object types which store data differently in these vectors.
 ! Object can be either simple or compound objects. Compound objects are linked to other
 ! objects which can be used also directly utilizing the standard naming conventions. All objects are
 ! global, i.e. also users can acces all objects. Some predefined objects are locked so that
 ! users cannot change them. 
 
 !There are three types of objects
 !\begin{itemize}
 !\item Named objects. The number of named objects is specified at the initilaization, 
 ! and it cannot be changed later. Deleting an object means deallocating all the allocated 
 ! vectors associated with the objects.
 !\item Temporary objects used to store intermediate results.
 !\item Temporary objects used to store the partial derivatives when computing the derivatives using
 ! the derivations rules.
!\end{itemize}

! Alongside the objects there is a vector of double precision values, call j\_v-vector. When an object is called a REAL
!object or variable, this vector is referenced. After the parts corresponding to named objects and
!those two sets of temporary objects, there is an area used to store numeric constants. If a REAL
! variable a has object number of 100 and constan 7 is in the  position 7000 in the v-vector,
! then a+7 can be presented as j\_v(100)+j\_v(7000). Thus after parsing, all arithmetic computations can be done wihtou reference to whether
! a variable is in the named part or constant part of the j\_v-vector.
!Because the numeric contants are at the end section of the j\_v-vector, 
!new space can be added for the numeric
! constants without mixing up parsed transformations.
!endsection



!Section system System requirement
!
 

! Figures are made with Gnoplot.
!gnuplot is freely available at

 
 ! https://sourceforge.net/projects/gnuplot/files/gnuplot/5.4.2/
 
 ! Download  download gp542-win64-mingw.exe. This will install gnuplot on your windows
! system under C::\textbackslash Program Files\gnuplot\. Jlp22 will strat gnuplot automatically when
! plotting figures if gnuplot is on the PATH (see section Installing gnuplot and Jlp22).
! Dcomentation is found also in \ref{gnu}

!endsection



!Section setup Set-up of J
! The maximum number of available objects cannot be changed during a Jlp22 session. It is determined during 
! the initialization. When Jlp22 is started it tries to read first file j.par from the default directory 
! (see 'During the first use' chapter): The first line must look like
! *2000
! where the number gives the maximum number of named objects.  If j.par is not available, the default 
! number of objects is 5000.
! Thereafter there can be in j.par file any number of Jlp22 commands executed directly (e.g. 
! you can give shortcuts for 
! commands which are handy e.g. when including repeatedly certain sections from include files). If you 
! want to go directly into a specific Jlp22-application, you can put into j.par the corresponding include 
! command.
! If Jlp22 is started from command prompt, there can be an include file name in the command line. This 
! include file is run after commands read from j.par if it is available.  ?TESTAA
!endsection

!Section firstuse	During the first use
! It is reasonable to have the exe versions and dll's found in 
!Jbin folder in one folder, and to make shortcuts for exe-files
! into all working folders. Edit the properties of the shortcut (right click the 
! shortcut icon) so that the starting directory is the working directory. Or 
! alternatively you can set the path to the folder containing Jlp22 executable and 
! run Jlp22 in your working directory. Copy also the file j.par into each working 
! directory.
! It is recommended that Jlp22 is run in the Command Prompt window even if it can be 
! run also directly from the program shortcut.
! Edit first the properties of the I/O window if you are using Jlp22 directly or from 
! the Command Prompt window. The properties of the I/O window can be changed by 
! right-clicking the-icon at the upper left corner. It is reasonable to make the 
! screen buffer rather large (large height) so that the whole history of the Jlp22 
! session can be seen (this is done in the layout sheet of the shortcut 
! properties). The default height of the I/O window is also probably too small. 
! The width should be at least 81. If you would like to use mouse in copy and 
! paste, put quick edit option on. Also the colours of the text and background of 
! the Jlp22 window should be made healthier for eyes (dark text, bright background).
! To see that Jlp22 is running properly, give your first commands at sit> prompt:
! sit>a=7.7;
! 
! The result should look 
! a=7.700000
! sit>
!It is possible to use arrow keys to gwt previous command lines.
!
! All input lines entered or generated by input programming at sit> prompt are 
! called commands. Commands are either input programming commands (input 
! commands) or commands that define operations in the Jlp22 working environment 
! (operation commands). Input commands and operation commands may read and 
! interpret more input lines before returning control to the command level.
! It is most convenient to develop Jlp22 applications using include files. There is 
! available in the jdocdemo folder an include file jexamples.txt 
! which can be used to run all examples in this manual. If the include file
!is in the working directory you can run any example by wrting the name of the example
! in the Jlp22-window if you have given ';incl(jexamples.txt)' at the sit> pronpt. 
! The working environment of Jlp22 consists of named objects, temporary objects, 
! constants, functions, arithmetic operations and text paragraphs. Operation 
! commands define simple arithmetic operations or more complicated operations on 
! the data structures. Operation commands are defined using a transformation 
! language. In addition to operation commands, the same transformation language 
! is used to define transformation objects which are computed as a group, usually severl times,
! and which 
! can be linked in different ways to data structures or other 
!transformation objects.
!endheader
!endsection

!Section exit	end ends Jlp22
!To exit Jlp22 program and close console window, just give end command:

!sit>end
!endheader
!endsection

!Section typo Typographical conventions
!endsection
!Section wrfunc sin() is a function
!endsection
!Section wropt xrange-> is an option
!endsection
!Section wrinpu ;incl is and input programming function
!endsection
!Section wrobj matrixa is an object
! Names matrixa, matrixb, proba,probb, jlpa,jlpb etc
! are common names used for matrices etc. Coloring of object names is not yet complete.
!endsection
!Section wrtype MATRIX is shorthand notaion for a matrix object
!if(type(matrixa).eq.MATRIX)then ..
!endsection


!Section onames Object names
!Object names start with letter or with {$#}. Object names can contain any of 
! symbols {#%§/\_} Jlp22 is using '%' to name objects related to some other objects. 
! E.g. function stat(x1,x2,mean->) will store means of variables x1 and x2 into 
! variables x1%mean and x2%mean. Objects with name starting with '$' are not 
! stored in the automatically created lists of input and output variables when 
! defining transformation objects. The variable Result which 
! is the output variable, if no output is given, is not put into these lists.
! Object names can contain special characters (e.g. +-*=()) if these are closed 
! within ‘[‘ and ‘]’, e.g. a[2+3]. This possibility to include additional information
! is borrowed from Markku Siitonen, the developer of Mela software.
! If an transformation object is created with trans() function, and the
! intended global arguments are given in the list of arguments,
! then a  local object {ob} created e.g. with transformation object {tr} have prefix
! {tr/\} yelding {tr/\ob}. Actually also these objects are global, but their prefix
! protects them so that they do not intervene with objects having the same name in the
! calling transformation object.
! There are many objects intialized automatically.
! Some of these are locked so that the users cannot change them. In transformation objects
! there can be objects which are intended to be used only locally. These are protected
! by putting an unvisible prefix to the object names, but these can be anyhow accessed
! by writing the prefix.
! Names of objects having a predefined interpretation start with capital letter. 
! The user can freely use lower or upper case letters. Jlp22 is case sensitive.
! All objects known at a given point of a Jlp22 session can be listed by command:
! print(Names)
!endheader
!endsection



!Section copy 	Copying object: a=b
!A copy of object can be made by the assignment statement a=b.
!endheader
!endsection

!Section delete delete_o() :deleting objects 
! When an object with a given name is created, the name cannot be removed. With 
! delete_0() function one can free all memory allocated for data structures needed 
! by general objects:
! delete_o(obj1,...,objn)
! After deleting an object, the name refers to a real variable (which is 
! initialized by the delete_o() function into zero).
!endheader
!Note  Other objects except matrices can equivalently be deleted by giving 
! command
! obj1,...,objn = 0
! This is because the output objects of any functions are first deleted before 
! defining them anew. Usually an object is automatically deleted if the object 
! name is as an output object for other functions.
!endnote
!Note One can see how much memory each object is using print(Names).
!endnote
!Note Deleting a compound object deletes also such 
! subobjects which have no meaning when the main object is deleted. But e.g. if a 
! data object is deleted then the as-sociated transformation object is not 
! deleted as the transformation can be used independently.
!endnote
!Note Files can be deleted with delete_f(file). See IO-functions for 
! details.
!endnote
!Note If the user has defined own new compound objects in the open source 
! Jlp22 software she/he needs to define the associated delete function.
!endnote
!endsection


!Section otypes Object types
! The following description describes shortly different object types available in 
! J. More detailed descriptions are given in connection of Jlp22 functions which 
! create the objects and in Developers' guide.
!endheader
!endsection


!Section realo Real variables and constants
! A REAL variable is a named object associated with a single 
! double precision value. Before version J3.0 the values were in single
! precision, and thus this objecttype is still called REAL. 
! The 
! value can be directly defined at the command level, or the variable can get 
! the value from data structures.  E.g.
!endheader
!Ex2 hopo2
!  stat(D,H,min->,max->) ! Here arguments must be variable names
!endex2
!Ex2 real giving value to REAL
! a = sin(2.4) ! argument is in radians sind() is for degrees
! h = data(read->(x1...x4))   ! x1, x2 ,x3, x4 are variables in the data set, and 
! get their values when doing operations for the data.
!endex2

! All numeric constants appearing in transformations will be stored
! as double precision 
! constants.
! Intermediate results in arithmetic calculations are stored into unnamed REAL
! variables.

!Note All objects have also an associated REAL value. In order to make 
! arithmetic operations fast, the argument types in simple arithmetic functions 
! are not checked. If a general object is used as an argument in an arithmetic 
! operation, then the REAL value associated with the object is used. This will 
! usually prevent the program to stop due to Fortran errors, but will produce 
! unintended results.
!endnote

!Note  In this manual 'variable' refers to a Jlp22 object whose type is REAL.
!endnote
!endsection

!Section charo Character constants and variables
! Character constants are generated by closing text within apostrophe signs ( ' 
! ). Apostrophe character ( ' ) within a character constant is indicated with (~) 
! (if the character ~ is not present in the keyboard, it can be produced by <Alt 
! >126, where numbers are entered from the numeric keyboard) Character constants are used e.g.  in I/O functions for file names, formats 
! and to define text to be written.  , e.g
!endheader
!Ex2
! a = data(in->'file1.dat', read->(x1,x2)) &
!endex2

!Ex2
! write('output.txt', '(~kukkuu=~,4f7.0)', sqrt(a)) & 
!endex2
!Latex
! Character variables are pointers to character constants. An example of a 
! character variable definition:

!endlatex 

!Ex2
! cvar='file1.dat' & 
!endex2
!Latex
! After defining a character variable, it can be used exactly as the character 
! constants.
!/endlatex
!Note The quotation mark (") has special meaning in the input programming. See 
! Input programming how to use character constants within character constants.
!endnote
!endsection

!Section textob	Text objects
! Currently there are two text object types, the old text object TEXT and the new 
! TXT. The TEXT object stores text in a long vector of single characters. The TXT
! object stores text in lines of 132 characters. The TEXT objects save memory but
! are not so easy to modify and use. Several Jlp22 
! functions create associated text objects. Jlp22 functions text() and txt() 
! can be used to 
! create text objects directly. All the names of Jlp22 objects are also stored in a 
! TEXT object called Names. The number of lines in a text objects can be obtained 
! with nrows() function and the total number of characters can be obtained with 
! len() function.
!endsection

!Section logical0	Logical values
! There is no special object type for logical variables. Results of logical 
! operations are stored into temporary or named real variables so that 0 means 
! False and 1 means True. In logical tests all non-zero values will mean True. 
! Thus e.g. if(6)b=7 is legal statement, and variable b will get value 7. E.g.
!endheader
!Ex2 
! sit>h=a.lt.b.and.b.le.8 &
! sit>print(h) &
! h=   1.00000 &
!endex2
!endsection

!Section listo Object lists
! An object list is a list of named Jlp22 object. See Shortcuts for implicit object 
! lists and List functions for more details. Object lists can be used also as 
! pointers to objects, see e.g. the selector option of the simulate() function.
!endsection



!Section matrixo	Matrices and vectors
! Matrices and vectors are generated with the matrix() function or they are 
! produced by matrix operations, matrix functions or by other Jlp22 functions. E.g. 
! the data() function is producing a data matrix as a part of the compound data 
! object. Matrix elements can be used in arithmetic operations as input or output 
! in similar way as real variables.
! See Matrix computations.
!endsection


!Section transo Transformation object
! A transformation object groups several operation commands together so that they 
! can be used for different purposes by Jlp22 functions and Jlp22 objects. A 
! transformation object contains the interpreted transformations. For more details 
! see Jlp22 function for defining transformation objects: trans().
! Transformation objects can be called using call() function, so that all 
! transformations defined in the object are done once. Function result() also calls 
! transformations but is also returning a value. When transformation objects are 
! linked to data objects, then the transformations defined in trans-formation object 
! are done separately for each observation.
! There is an implicit transformation object $Cursor$ which is used to run the 
! command level. The name $Cursor$ may appear in error messages when doing 
! commands at command level.  An-other transformation object $Val$ which is used to 
! take care of the substitutions of "-sequences in the input programming. Some Jlp22 
! functions use also implicitly transformations object $Cursor2$.
!endsection




!Section problemo	Problem definition object
! Problem definition object is a compound object produced by the problem() function, and it is 
! described in Linear programming.
!endsection




!Section storageo	Storage for variables
! Especially in a simulator it may happen that a set of variables have certain 
! values but the same variables are used for other purposes for some time and 
! then one would like to get the previous values. There is special Jlp22 object used 
! to store the values, and special store() and load() functions to deal with the 
! storage.
!endsection

!Section bitmatrixo	Bitmatrix
! A BITMATRIX is an object which can store in small memory space large matrices 
! used to indicate logical values. A BITMATRIX object is produced by bitmatrix() 
! function or by closures() function from an existing bitmatrix. Bitmatrix values 
! can be read from the input stream or file or set by setvalue() function. The 
! values of bitmatrix elements can be accessed with value() function.
!endheader
!Note: Also ordinary real variable can be used to store bits. See bit functions.
!endnote
!endsection

!Section traceo Trace set
! TRACESET is an object created by ;trace() function which is used by 
! tracetest() function to test if a set of variables has been updated. See 
! chapter Tracing variables.
!endsection






!Section cominout Command input and output
! Jlp22 has two programming levels. First level, called input programming, generates text lines which are then
! transmitted to the parser which generates code which is the put into transformations sets or 
!excuted directly. Input programming loops make it possible to generate large number of command lines 
! in a compact and short form. This chapter describes input programming concepts and commands.
!endsection
!Section inpuline Input record and input line 
!Jlp22 reads input records from the current input channel which may be the console, file or a text object.
! When Jlp22 interprets input lines, spaces between limiters and function or object names are not
! significant. In input programming, functions start with ';' which is part of the function name (and
! there can thus be no space immediately after ';'). If a line (record) ends with ',' ,'+', '*´, '-',
! '(', '=' or with '>', then the next record is interpreted as a continuation record and
! the continuation character is kept as a part of the input
! line. Tf a record ends with ',' and the next record starts also with ',', only one ',' is obtained. If a line ends with '>{}>', then
! the nex line is also continuation line, and  '>{}>' is ignored. All continuation
! records together form one input line. In previous version input programming functions operated on input lines
! but now they operate on recors. One input record can contain 4096 characters, and an input line can contain also 4096 characters
! (this can be increased if needed).
! There can be comment lines within a command line.  

! When entering input lines from the keyboard, the previous lines given from the keyboard can no more be
! accessed and edited using the arrow keys owing to MSYS2 MSYS environment used to build the exe-file.
! To copy text from the Jlp22 window into the clipboard right-click the upper left icon, select Edit,
! and then select Mark. Next click and drag the cursor to select the text you want to copy and
! finally press Enter (or right-click the title bar, select Edit, and in the context menu click Copy).
! To paste text from the clipboard into the Jlp22 command line right-click the title bar, select Edit,
! and in the context menu click Paste. Console applications of Intel Fortran do not provide copy
! and paste using <cntrl>c and <cntrl>v. An annoying feature of the current command window is that it is possible 
! All input lines starting with '*' will be comments, and in each line text starting with '!' will also
! be interpreted as comment (!debug will put a debugging mode on for interpretation of the
! line, but this debug information can be understood only by the author). If a comment line starts
! with '*!', it will be printed.
!endsection

!Section inpupara Input Paragraph
! Many Jlp22 functions parsed and executed (interpreted) at the command level need or can use a group of
! text lines as input. In these cases the additional input lines are immediately after the function.
! This group of lines is called input paragraph. The input paragraph ends with '/', except the
! input paragraph of text function text() and txt() end with '//' as a text object can contain ordinary input
! paragraphs. It may be default for the function that there is input paragraph following. When
! it is not a default, then the existence of the input paragraph is indicated with option in->
! without any value. For many functions, the input paragraph can contain input programming commands.
! The resulting text lines are transmitted to the function which interprets the input paragraph either using
! the parser (e.g. trans() function) or by other means (e.g problem()).
!endheader
!Ex inpuparag Example of inputparagraph
! transa=trans()
! a=log(b)
! write($,'(~sinlog is=~,f4.0)',sin(a))
! /
! b=matrix(2,3,in->)
! 1,2,3
! 5,6,7
!/
!endex
!endsection

!Section inpuif ;if()...
!If the condition within the parenthesis if TRUE (i.e. has a nonzero value)the following text if the next input line
!generated.
!endheader
!Note In the previous J version it was possible to write these one line ifs outsoed a TRANS object 
! the semicolon, i.e. in form  if().... Now this is not allowed, even if it would be simple to implement
!in order to  make a clear distinction between input programming and transformations
!endnote
!endsection

!Section inpuifthen ;if();then
! If the conditon within the parenthesis is tRUE (i.e. ahas a nonzero value, the text up to
! ;elsif());then or ;else  becosme part of the input. Thus the whole thing can look like
! ;if(...);then\\
! ...\\
! ;elseif(...);then\\
! ...\\
! ;elseif(...);then\\
! ...\\
! ;else\\
! ...\\
! ;endif\\
!endsection

!Section short Shortcuts
!Command shortcuts are defined by defining character variables. When entering the 
! name of a character variable at sit> prompt or from an include file, Jlp22 excutes the command.
!The command can be either input programming command or one-line command. The file jexamples.inc
!shows an useful way to organize shortcuts and include files.
!endheader
!Ex shortex Example of using shortcuts and include files
!short1='sin(Pi)+cos(Pi);'
!short1
!te=text()
!this=thisfile()
!ju1=';incl(this,from->a1)'
!ju2=';incl(this,from->a2)'
!;return
!;a1:
!!! greetings from a1
!;return
!;a2:
!** here, jump to a1
!ju1
!*! back here, return to sit> or next example in ALL
!;return
!//
!write('shortex.txt',$,te)
!close('shortex.txt')
!;incl(shortex.txt)
!ju1
!ju2
!delete_f('shortex.txt')
!te=0 !delete also text object te
!endex
!endsection

!Section now ;now() doing something immedidately
!;now() Executes immediamently the code within parenthesis. This is useful 
!  within trans() or within problem() when ;do() is present.
!endheader
!Ex nowex
tr=trans()
;do(i,1,3)
;enddo

!endex 
!endsection

!Section inpuprog Input programming
! The purpose of the input programming is to read or generate Jlp22 commands or input lines
! needed by Jlp22 functions. The names of input programming commands start with semicolon ';'.
! There can be no space between ';' and the following input programming function. The syntax
! of input programming commands is the same as in Jlp22 functions, but the input programming
! functions cannot have an output. There are also control structures in the input programming.
! An input paragraph can also contain input programming structures.
!endsection

!Section inpuad  Labels in input programming

! The included text files can contain labels. Labels define possible starting points for the
! inclusion or jump labels within an include file. A label starts with semicolon (;) and
!ends with colon (:). There can be text after the label and the text is printed but
! otherwise ignored.\\

!endheader

!Ex2
! ;ad1:  At this point we are doing thit and that
!endex2


!Note The definition of a transformations object can also contain labels. These labels start
! with a letter and end also with colon (:). When defining a transformation object with trans() function,
! the input paragraph can contain input programming labels and code labels. It is up to 
! input programming what code alabels become part of the transformation object.
!endnote


!endsection



!Section inpureplace Changing "i" sequences
! If an original input line contains text within quotation marks, then the sequence will be replaced
! as follows. If a character variable is enclosed, then the value of the character variable is
! substituted: E.g.
! directory='D:/\j/\'
! name='area1'
! extension='svs'
! then
! in->'"directory""name"."extension"'
! is equivalent to
! in->'D:/\j/\area1.svs'
! If the "-expression is not a character variable then Jlp22 interprets the sequence as an arithmetic
! expression and computes its value. Then the value is converted to character string and
! substituted into the place. E.g. if nper is variable having value 10, then lines
!Listing
! x#"nper+1"#"nper" = 56
! chv = 'code"nper"'
!endlisting
! are translated into
!Listing
! x#11#10 = 56
! chv = 'code10'
!endlisting

! With " " substitution one can define general macros which will get specific interpretation by
! giving values for character and numeric parameters, and numeric parameters can be utilized in
! variable names or other character strings. In transformation sets one can shorten computation
! time by calculating values of expressions in the interpretation time instead of doing
! computations repeatedly. E.g. if there is in a data set transformation
! x3 = "sin(Pi/4)"*x5
! Then evaluation of sin(Pi/4) is done immediately, and the value is transmitted to the
! transformation set as a real constant.
! If value of the expression within a “” sequence is an integer then the value is dropped in the
! place without the decimal point and without any spaces, otherwise its value is presented in
! form which is dependent on magnitude of the value. After J3.0 the format can be explicitly
! specified within [] before the numeric value. Eg. text can be put into a figure as
! fig =
! drawline(5,5,mark->’y=”[f5.2]coef(reg,x1)“*x1+”[f5.2]coef(reg,1)“‘)
! See file jex.txt and Chapter 8 for an ex
!endheader
!endsection

!Section inpureturn ;return from ;incl
!;return in an input file means that the control returns to the point where a 
! jumpt to an label was found. Two different cases need to be separated:
!endheader
!Latex
!\begin{itemize}
!\item The conrol came to the starting label or to the beginning of the include file 
!from outside the current include file using a ;incl command. Then ;return returns the control to upper level include 
! file or to the sit> prompt.
!\item The control came to the starting label from within the same include file using
! an explicit ;incl or ;incl is generated  
! with command shortcut.
!\end{itemize}
!endlatex
!endsection





!Section dots ...  sequences 
!It is often natural to index object names, and often we need to refer object
! names having consecutive index numbers or index letters. In Jlp22 versions before version 3.0 it
! was possible to generate object lists using ... -construct which replaced part of
! the input line with the names of objects being between the object 
! name before ... and after ... . Now the dots construct is no more done as
! part of the input programming but in the interpret subroutine which interprets the
! input line and generates the integer vector for function and argument indices.
!But as dots work as if it would be part of the input programming, it is presented in this
! section. Currently also sequences of integer constants can be generated with dots and
!sequences can be from larger to smaller.
!endheader
!Ex dotsex Example of dots construct
!dat=data(read->(x4...x7),in->)
!1,2,3,4
!11,12,13,14
!/
!stat(min->,max->,mean->)
!x3%mean...x7%mean;
$$=300
!A...D=4...1;
!Continue=1  !demo of error in data()
!dat=data(read->(x3...x7),in->)
!1,2,3,4
!11,12,13,14
!/
!Continue=0
!endex
!endsection

!Section inpulistelem @List(index) Gets a name from a LIST
!The name of an object in a LIST can be obtained into the input using the following example.
!endheader
!Ex inpulistelem Getting name from LIST
! lis=list(c2...c5);
! @lis=2...5;
! @lis(2)=6;
! @lis(4)=@lis(1);
! @lis(2)%@lis(4)=66;  
!** Utilizing LISTs  of LISTs
! lists=list(lis1...lis3);
! lis1=list(x1...x4);
! @lis1=1...4
! lis2=list(z1...z3);
! @lis2=10,20,30
! lis3=list(y1,y2);
! @lis3=100,200
! ** @lists(2) drops lis2 to the input line giving @lis2; which cause 
! ** that elements of lis2 are printed
! @@lists(2);
!endex
!endsection

!Section sublist lista(2,-4) makes LIST from part of LIST lista
! A list can be made taking a part of LIST.
!endheader
!Ex sublistex taking sublist
!lista=list(x1...x5);
!lista2%5=lista(2,-5);
!endex
!endsection


!Section expand @List expands a LIST 
!If a LIST is generated explicitly with list() function or as a byproduct of an other function,
! then all elements of the list can put into the code using @-sign in the front of the name of the list. 
! The code then works similarly as if all the object names had been written consecutively and separated
! with commas. 
!endheader
!Note A function or an option can have several parts in the arguments generated with @
!endnote
!Note In the earlier versions of the software,expanding lists with @ was implemented during the generation of 
! the input line similarly as in the input programming proper. This was stupid. It is more simple and more efficient to
! to implement the expanding of lists during the code parsing stage. This is presented here because, @-sign works
! as if it were part of input programming. 
!endnote
!Ex expandex Example of expanding lists with @
!list0=list(site,altitude)
!list1=list(
!;do(i,1,3)
!vol"i",ba"i",
!;enddo
!vol4,ba4);
!dat=data(in->,read->(@list0,@list1))
!1,2,3,4,5,6,7,8,9,10
!2,3,4,5,6,7,8,9,10,11
!/
!stat()
!endex

!endsection
!Section inpusubobj Objects with common part of name
! There are two ways to acces objects having common part in name. These methods are especially useful
! when seeing sub objects or side object produced with funtion whose names start with output%.
!endsection

!Section inpusub1 Printing names of subobjects
!The names of subobjects generated with a function can be seen according 
! to the following example. 
!endheader
!Ex subobjex Seeing subobjects
!dataa=data(in->,read->(x,y))
!1,2
!3,4
!/
!dataa%?; !prints subobjects
!endex
!endsection

!Section inpusub2 ;list(part%?) LIST of objects having common part in name
! ;list() Makes a list of objects. The example shows how the list can be printed and how 
!to print all objects in the list.
!endheader

!Ex subobjex2 
!dataa=data(in->,read->(x,y))
!1,2
!3,4
!/
!lista=;list(dataa%?);
!**Then all objects in the list are printed.
!@lista;
!**Seeing and printing relatives 
! x1a...x3a=3...5
!x?a;
!rel=;list(x?a);
!@rel;
!endex
!endsection

!Section inpusub2b ;list(part%?) LIST of objects having common part in name
! ;list() Makes a list of objects. The example shows how the list can be printed and how 
!to print all objects in the list. This function is described also in section \ref{inpusub2}
!endheader

!Ex subobjex2 
!dataa=data(in->,read->(x,y))
!1,2
!3,4
!/
!lista=;list(dataa%?);
!**Then all objects in the list are printed.
!@lista;
!endex
!endsection

!Section jtrans Jlp22 transformations
! Most operation commands affecting Jlp22 objects can be entered directly at the command level or
! packed into transformation object. In both cases the syntax and working is the same. A
! command line can define arithmetic operations for real variables or matrices, or they can
! include functions which operate on other Jlp22 objects. General Jlp22 functions can have arithmetic
! statements in their arguments or in the option values. In some cases the arguments must be
! object names. In principle it is possible to combine several general Jlp22 functions in the same
! operation command line, but there may not be any useful applications yet, and possibly some
! error conditions would be generated.
! Definition: A numeric function is a Jlp22 function which returns a single real value. These functions
! can be used within other transformations similarly as ordinary arithmetic functions. E.g.
! weights() is a numeric function returning the number of schedules having nonzero weight
! in a JLP-solution. Then print(sqrt(weights())+Pi) is a legal transformation.
!endheader
!endsection

!Section jfuncs0 Jlp22 functions
! The structure of Jlp22 functions is easiest to explain using an example.
!For instance a data object can be created with \\
! data2=newdata(matrx,matrz,read->(x1...x3,z1...z4),maketrans->mt) \\
! Here ]data2[ is the output, ]matrx[ and ]matrz[ are matrices having equal number of rows. Matrix 
! ]matrx[ has 3 columns, ]matrz[ 4. read-> is an option which tells
! what are the variable names in the data. x1...x3 is equivalent to x1,x2,x3.  Option   
!maketrans->mt tells that for each observation the trasformations defined in the trasformation
! object ]mt[ are computed from variables x1...x3 and z1...z4. The output variables
! whose names do not start with $ are included in the DATA object. 
 

!A function call obtained from the  input programming can have the 
! following components separed with commas. 
!endsection

!Section output Output of a function

!  There are the following cases with respect to
 ! the output of the function
 
 ! \begin{itemize}
 
 !\item The function appears in a code line looking like\\
! Output=func()\\
!Then the function produces an object ]Output[. The type of the ]Output[ depends on the function.
! Several functions produce additional objects whose name start with ]Output%[. The
! object ]Output[ may or may not store links to these object. If such links are 
! stored then the output is a compound object. An objects to which there is a link, is called a subobject.
! Objects without such links are called side objects. For instance linear programming function jlp()
! does not produce any object with name ]Output[ just several side objects. 

! \item The expression \\
! func()\\
! is equivalent to\\
! Result=func()
! \item If code line is Output=func(); or func(); the Output or Result are printed if
! variable Printvalue has value 1 or 3.  If code line is Output=func();; or func();;
! if variable Printvalue has value 2 or 3.  

! \item Output is a temporal object. If a function is part of arithmetic computations, then
! the intermediate results are stored into temporary objects according to the parse tree. Thus in the
! expression y=sin(x)+cos(x), sin(x) produses first a temporary object and cos(x)
 ! another temporary object.
 ! \item Output is a submatrix of a MATRIX object. If A is a 4x4 matrix, and
 ! B is a3x3 MATRIX,then expression\\
! A(2,-4,1,-3)=B\\
! puts MATRIX B into A.
!\end{itemize}
!endsection

!Section functionname Function names

!  Function name can be be any of the four cases.
! \begin{itemize}

! \item A standard Jlp22 function,
! \item An arithmetic or logical function obtained when translating the code into the polish notation.nslated first into
 ! Thus \\
! if(region.eq.savo)c=2*3+4;\\
! is translated into \\
! if(EQ(region,savo))c=PLUS(MULT(2,3),4);\\
! The user can try directly the above translated form
! \item An own-function of the user included in the function space.

! \item Implicit function generated with the parser. For instance, options are implemented using 
! setoption() function.
! \item Jlp22 object which can be used as if it were a function. Currently there
! are four such cases
!\end{itemize}
!endsection

!Section matrixfunc MATRIX as a function
!If matrixa is a MATRIX then expression matrixa() can be both in the input side or output side to indicate
! a submatrix or element of the matrix. See matrix chapter.
!endsection

!Section realmatrix REAL as a MATRIX
!Often in matrix computations, a REAL is a limiting value of a sequence of matrices.
!To facilitate such computations, matrixa(1) and matrixa(1,1) are legal ways to refer to matrixa even if it is REAL.
!If matrixa is REAL, then expression matrixa(3) is causing error:\\
!matrixa is REAL, ranges            3  are illegal, only (1) or (1,1) are allowed
!endsection


!Section datafunc DATA as a function
!If Data is  DATA then Data(var1,..,varn) indicates a matrix obtained by picking 
! the columns of the data matrix corresponding the argument variables.
!endsection

!Section transfunc0 TRANS as a function
! If Trans is TRANS, then Trans(]a[) is object ]a[ as produced with the transformation.
! That is, the transforamtion is first executed. After calling Trans also other
! output objects are available. Because options need to be processed before arguments,
! the parse tree is processed from right to left, which mus be taken into account
! when using TRANS as if it were an function. See more in Chapter ?.
!endsection

!Section regrfunc REGR as a function
! If Regr is a regression object produced with regr, then Regr() produces
! the value of the regression function as explained for regr(). The values of arguments
! can be given in the calling code or the existing values can be used.
!endsection

!Section isnotfunc Cannot produce -error
! If the code looks like a function, the control goes to j\_getelem function
! which computes the results for the above mentioned object types. But if
! the object cannot produce anything, there will be an error message:\\
! produce   but it is not a function or object which can provide something then
!there will be an error message:\\
!* (object name) cannot produce anything
!endsection

!Section isreal is REAL ranges .. illegal  -error
!If the object is REAL then the error message can be \\
!matrixa is REAL, ranges            5  are illegal, only (1) or (1,1) are allowed\\
! A REAL can be treated as a 1x1 MATRIX, so for REAL ]var[ var(2,2) means illegal dimensions.
!endsection





!Section arguments Arguments of a function
! Arguments separated with commas. Arguments can be a combination of the following types
! \begin{itemize}
! \item object name
! \item numeric constant
 ! \item A code which produces a temporary object generated with any Jlp22 functions
 ! \item a sequence of object names generated with ... as x1...x3 above.
 ! \item @List where ]List[ is a LIST. If ]List[ is obtainedwit ]List[=list(x1...x3), then
 ! @List is equivalent to x1...x3 which is equivalnet to x1,x2,x3.
! \end{itemize}
!endheader
!Ex2 hopo
! a = sin(cos(c)+b) ! Usual arithmetic functions have numeric values as arguments.
!  here the value of the argument of cos is obtained by 'computing' the
! value of real variable c. 
!endex2
!Ex2 hopo2
! stat(D,H,min->,max->) ! Here arguments must be variable names
!endex2
!Ex2 hopo3
! plotyx(H,D,xrange->(int(D%min,5), ceiling(D%max,5))) !arguments of the function are variables, arguments of option xrange-> are numeric values 
!endex2
!Ex2 hopo4
! c = inverse(h+t(g)) ! The argument can be intermediate result from matrix computations.
! If it is evident if a function or option should have object names or values as their arguments, it
! is not indicated with a special notation. If the difference is emphasized, then the values are
! indicated by val1,...,valn, and objects by obj1,...,objn, or the names of real variables are
! indicated by var1,...,varn.
! There are some special options which do not refer to object names or values. Some options
! define a small one-statement transformation to be used to compute something repeatedly.
!endex2

!endsection

!Section options Options of a function
! Options give additional arguments to the function.
!endsection
!Section optionstructure Option structure
!An option starts with the option name
! followed with '->' after which there can be
! \begin{itemize}
! \item Nothing. In this case the option indicated that the option is put 'on'. E.g. 
! continue-> in a graphics function indicates that no pause() is generated after plotting the figure.
! \item Numeric value, e.g. continue->]fcont[ in a graphics function 
! indicates that no pause() is generated if a REAL object ]fcont[ has a nonzero value.
 
! \item Object name.
! \item Function name followed by the arguments within parenthesis, e.g., 
! xrange->(0,ask('xmax')) where ask() is the function which asks a numeric value from the user.
! \item Arguments of the option expressed in the same way as the arguments of the function, i.e.,
! using acode which is producing a temporary object.
!\end{itemize}
!endsection

!Section codeoption Codeoptions
!Options are grouped into two groups: code options and regular options. 
! Code options 
! define a small one-statement transformation to be used to compute something repeatedly. 
! As these one-statement can use transformation objects as functions, the code option can actually
! execute long computations. For instance \\
! stat(D,H,filter->(region.eq.savo)) \\
! only those observations are accepted which pass the filter.\\
! draw(func->(sin($x)+1),x->$x,xrange->(0,10,1),continue->fcont)\\
!func-> option
! transmits the function to be drawn not a single value.
!endsection
!Section regularoption Regular options
! Regular option which is just processed once before entering a function
!
!endsection



!Section classes Analyzing classified data
!The are several functions which can be used to analyze classified data.
!All these functions are described here, even if they belong Figure functions and
! statistical functions. 
!endsection 




!Section Data Data functions 
!Data functions can generate data objects by reading data from files, or forming data
! objects by combing matrices and data objects. An important property of data objects
! is that they can be linked so that each observation of an upper level data
! is linked to several observations in lower level data. Each upper level 
!observation can contain different number of lower level observations.
!Linear programming in forest management planning is based on linked data sets where each
!stand is connected to number of treatment schedules.
!endheader
!endsection

!Section jfunc Structure of general Jlp22 functions
! The general (non arithmetic) Jlp22 functions are used either in statements

! func(arg1,...,argn,opt1->value1,....,optm->valuem)

! or

! output=func(arg1,...,argn,opt1->value1,....,optm->valuem)

! If there is no output for a function in a statement, then there can be three different cases:
! Latex
! \begin{itemize}
! \item The function does not produce any output (if an output would be given, then Jlp22 would just 
! ignore it

! \item The function is producing output, and the default name {Result} is used for the output  
! for arithmetic and matrix operations.
! \item The function is a sub expression within a transformation consisting of several parts including 
! other function or arithmetic operations. Then the output is put into a temporary unnamed 
! object which is used by upper level functions as an argument (e.g. a=inverse(b)*t(c)) 
! \end{itemize}
!endlatex
! If the value of an option is not a single object or numeric constant, then it must be enclosed in 
! parenthesis.
! endheader

! Note : It is useful to think that options define additional argument sets for a function. Actually 
! an alternative for options would be to have long argument lists where the position of an 
! argument determines its interpretation. Hereafter generic term 'argument' may refer also to 
! the arguments of an option.
! endnote
! Note : When Jlp22 is parsing a function, it is checking that the option names and the syntax 
! are valid, but it is not checking if an option is used by the function. Also when executing the 
! function, the function is reacting to all options it recognizes but it does not notice if there are 
! extra options, and these are thus just ignored.
! An argument for a Jlp22 function can be either functional statements producing a Jlp22 object as its 
! value, or a name of Jlp22 object. Some options can be without any argument (indicating that the 
! option is on).
! endnote
! Ex jfuncex Examples of Jlp22-functions
!b,c=2,3;
! a = sin(cos(c)+b); ! Usual arithmetic functions can have numeric values as arguments
!c=matrix(2,2,in->);
!1,2
!3,4
!/
! ** now c is MATRIX
! a = sin(cos(c)+b); 
! ! here the value of the argument of cos is obtained by 'computing' the value of real variable c.
! Dm=matrix(do->(0.1,40))
!nob=nrows(Dm)
! e=matrix(nob)
!e=rann()
!Hm=0.5+Dm**0.7+e
!dat=newdata(Dm,Hm,read->(D,H))
! stat(D,H,min->,max->) ! Here arguments must be variable names
! plotyx(H,D,continue->fcont) !arguments of the function are variables
! h=matrix(5,5);
!h=rann();
!g=matrix(5,do->5);
! c = inverse(h+t(g)); ! The argument can be intermediate result from matrix computations.
!endex
! endsection
 


! Section codeopt Code options
! There are some special options which do not refer to object names or values. Some options 
! define a small one-statement transformations to be used to compute something repeatedly. 
! As these one-statement can use transformation objects as functions, the code option can actually
! execute long computations.
! endheader
! Ex codeoptex Codeoptions
! dat=data(read->(D,H),in->)
! 3,2
! 2,4
! 4,1
! /
! stat(D,H,filter->(H.gt.D)) ! only those observations are accepted which pass the filter
! fi=draw(func->(sin($x)+1),x->$x,xrange->(0,10),color->Red,ylabel->'sin(x)+1',
! continue->fcont,xlabel->'x',width->2) ! the func-> option transmits the function to be drawn not a single value.
! endex
! endsection

! Section license Subroutines from other sources
! The following subroutines are obtained from other sources.
! endheader
! Latex
! \begin{itemize}

! \item  subroutine tautsp used in j\_function tautspline
! from Carl de Boor (1978) A practical guide to splines. Springer, New York, p.310-314
! No licence restrictions known.
! Distribution: \\
! \url{https://www.researchgate.net/publication/200744645_A_Practical_Guide_to_Spline},
! see also \url{ http://pages.cs.wisc.edu/~deboor}


! ! \item subroutine interv , used in function ppvalue
! ! from Carl de Boor (1978) A practical guide to splines. Springer, New York, p.310-314
! ! No licence restrictions known
! ! obtained from: http://pages.cs.wisc.edu/ ~deboor/ pgs/tautsp.f
! ! Lapack matrix routines

! \item Several subroutines from \url{www.netlib.org/lapack}
!with licence :\\
! \url{http://www.netlib.org/lapack/LICENSE.txt}
! \end{itemize}
! endlatex
! endsection





!Section comoptions Common options
! There are some options which are used in many Jlp22 functions. Such options are e.g.
!endheader
!Option
!@@in2@ 
!@@data@
!All data sets will be
! treated logically as a single data set. 
! If the function is using data sets, the daenta sets are given in data-> option. All data sets will be
! treated logically as a single data set. If a Jlp22 function needs to access data, and the data->
! option is not given then Jlp22 uses default data which is determined as follows.
! If the user has defined an object list Data consisting of one or more data sets, then these will
! be used as the default data set. E.g.
! Data=list(dataa,datab)
! When a data set is created, it will automatically become the only element in LastData list. If
! the Data list has not been defined and there is no data-> option, then the LastData dataset
! will be used.
!@@trans@
! In all functions which are using data sets, trans-> option defines a
! transformation set which is used in this function. 
!@@filter@
!endoption
!Ex comoptex data1
!dat=data(read->(x,y),in->)
!1,2
!3,4
!5,6
!/ 
! transa=trans()
! xy=x*y
!x,y,xy;
!/
! stat(trans->transa)
!endex
!endsection

!Section call call() executes TRANS object
!Parsed transformations in a TRANSobject can be automatically executed by other Jlp22
!functions or they can be executed explicitly using call() function.
!endheader

!call(tr)
!Option
!Arg&1&TRANS& The transformation object executed.
!endoption

!The call() function can be used at the command level or within transformation object. Defining
!transformation objects which are called within other transformation sets one can use some
!transformation as subroutines. Lists can be used to transmit objects into transformation
!objects similarly as done in more advanced programming environ ments using arguments.
!Using input
!programming one can define transformations which get specific interpretation after giving
!values to character variables and object lists. But these transformations must be interpreted
!first with trans() function before they can be used. It is also possible to transmit lists 
!into interpreted transformations.
!endheader
!Note: A transformation objects can be used recursively, i.e. a transformation can be called from
!itself. The depth of recursion is not controlled by J, so going too deep in recursion will
!eventually lead to a system error.
!endnote
!Note Professional programmers would probably say that the integer vector produced with the parser
! is interpreted and not executed. An amateur programmer can be more flexible with terms.
!endnote 
!Ex recursion Recursion produces system crash.
!transa=trans() !level will be initialized as zero
!level;
!level=level+1
!call(transa)
!/
!Continue=1  !error is produced
!call(transa)
!Continue=0
!endex
!endsection

!Section transfunc Using a transformation object as a function
! It is now possible to use a transformation object as a function which computes new
! objects when generating arguments for functions or options, 
! or values of code options, or in any place within a transformation object. 
! If {tr} is a transformation and the transformation computes an object {A} then
! {tr(A)} is first calling transformation {tr} and provides then object {A} into this place.
! As the transformation computes also other objects which are computed within it, also thes objects
! are available. At this point it is important to note that arguments of 
! a transformation line are computed from right to left, because options must be computed before
! entering into a function. 
! endheader
!Ex transfunc Transformation as a function
!delete_o(a,c)
! transa=trans()
! a=8;
! c=2;
! /
! transb=trans()
! a=5;
! c=1;
! /
! c=2
! a=c+transb(a)+c+transa(a);
!endex
!endsection

!Section arith Arithmetic and logical functions and operations
!Jlp22 has all the standard arithmetic and logical operations and functions.
!The arithmetic and logical functions return single REAL value or a MATRIX.
!endsection

! Section numer Numeric operations -, +, *, **, ***, /, *., /.
! An arithmetic expression consisting of ordinary arith metic operations is formed in 
! the standard way. The operations are in the order of their precedence.
! Latex
! \begin{itemize}
! \item - unary minus
! \item *** integer power
! \item ** or \^ real power
! \item * multiplication
! \item / division
! \item + addition
! \item - subtraction
! \end{itemize}
! endlatex

! The reason for having a different integer power is that it is faster to compute and a negative 
! value can have an integer power but not a real power.

 ! In matrix computations there are two additional operations.
 
 
! \begin{itemize}
! \item *. elementwise product (Hadamard product)
! \item /. elementwise division
! \end{itemize}


! The matrix operations are explained in section ?. Their operation rules extent
! the standard rules. 
! endsection
!!!'\textbf{J}'
! Section logic Logic and relation .eq. .ne. .gt. .ge. .lt. .le. .not. .and. .or. .eqv. .neqv.
! There are following relational and logical operations. The first alternatives
! follow Fortan style:
!endheader

 ! \begin{itemize}
! \item .eq. == equal to
! \item .ne. <> not equal
! \item .gt. > greater than
! \item .ge. >= greater or equal
! \item .lt. < less than
! \item .le. <= less or equal
! \item .not. ~ negation
! \item .and. & conjunction
! \item .or. disjunction
! \item .eqv. equivalent.
! \item .neqv. not equivalent
! \end{itemize}

! The relational and logical expressions produce value 1 for True and value 0 for False. 
! Note Testing equivalence can be done also using 'equal to' and 'not equal', as the same truth 
! value is expressed with the same numeric value.
!endnote
! Note when the truth value of an expression is tested with if(), then all nonzero real values
! means that the expression is true. 
! endnote


! endsection

! Section arfu1 Functions sqrt(), sqrt2(), exp(), log(), log10(), abs()
! 
! \begin{itemize}
! \item sqrt(x) square root, sqrt(0) is defined to be 0, negative argument produce error.
! If {x} is matrix, then an error occurs if any elemet is negative.
! \item sqrt2(x) If {x} or an element of {x} is negative then $sqrt2()=-sqrt()$. Actually sqrt2() might be a
! useful sigmoidal function in modeling context.
! \item exp(x) $e$ to power {x}. If {x}>88, then Jlp22 produces error in order to avoid system
! crash.
! \item log(x) natural logarithm
! \item log10(x) base 10 logarithm
! \item abs(x) absolute value
! \end{itemize}
!endsection

!Section trigfu Trig sin(),sind(),cos(),cosd(),tan(),tand(),cotan(),cotand()
! In sin(), etc,  argument is in radians, in sind(), etc in degrees
! \begin{itemize}
! \item sin()
! \item sind()
! \item cos()
! \item cosd()
! \item tan()
! \item tand()
! \item cotan()
! \item cotand()
!\end{itemize}
!endsection

!Section atrigfu arc-trig asin() asind() acos() acosd() atan() atand() acotan() acotand()
! Inverse trigonometric functions. In asin(), etc,  argument is in radians, in asind(), etc in degrees
! \begin{itemize}
! \item asin()
! \item asind()
! \item acos()
! \item acosd()
! \item atan()
! \item atand()
! \item acotan()
! \item acotand()
!\end{itemize}
!endsection

!Section hyper Hyperbolic  sinh() cosh() tanh()
! \begin{itemize}
! \item sinh()
! \item cosh()
! \item tanh()
! \end{itemize}
!endsection

! Section mod Functions mod() fraction()
! \begin{itemize}
! \item mod()
! \item fraction()
! \end{itemize}
! endsection


!Section conversion Conversion to integer

! \begin{itemize}
! \item nint(x) nearest integer value
! \item nint(x,modulo) returns modulo*nint(x/modulo) ,e.g.nint(48,5)=50; nint(47,5)=45;
! \item int(x) integer value obtained by truncation
! \item int(x,modulo) returns modulo*int(x/modulo), e.g. int(48,5)=45
! \item ceiling(x) smallest integer greater than or equal to {x}.
! \item ceiling(x,modulo) returns modulo*ceiling(x/modulo), e.g. ceiling(47,5)=50.
! \item floor(x) greatest integer smaller than or equal to {x}.
! \item floor(x,modulo) returns modulo*floor(x/modulo), e.g. floor(47,5)=45.
! \end{itemize}
!endsection

!Section minmaxjoku min() and max()
! The following rules apply both for min() and max(). The rules are presented here only for min().
! \begin{itemize}
! \item min(x1,...,xn): $n>1$ and all arguments are REAL, ]Result[ is REAL.
! \item min(A): If ]A[ is matrix then the result result is row vector containg minumum
! of each column. If ]A[ is a column vector, ]Result[ is REAL.
! \item min(A,any->) If ]A[ is matrix, then ]Result[ minimum over all elements.
! \item min(x,A) If ]x[ is REAL and ]A[ is matrix, then ]Result[ is
 ! matrix with the same dimensions as ]A[ and 
 ! ]Result[(i,j)=max(]x[,]A[(i,j)). The order of arguments does not matter.
 ! \item min(A,B), ]A[ and ]B[ compatible matrices. ]Result[ is amatrix with the same dimesnions containg elementwise
 ! minimums.
! \end{itemize}
! endsection

!Section sign sign(A,B)
!sign(A,B) returns the value of A with the sign of B.
!endsection

!Section statistics Statistical functions
! There are several statistical functions which can be used to compute basic statistics
!linear and and nonlinear regression, class means, standard deviations and standard errors 
! in one or two dimensional tables using data sets. There are also functions
! which can be used to compute statistics from matrices, but these are described 
! in Section  \ref{matrix}
!endsection

!Section matrixf  MATRIX functions
! There are matrix function which can create matrices (objects with type Matrix), take submatrices from larger matrices,
! make matrices from submatrices, compute statitics from matrices, solve linear equations,
! compute inverse and transpose of a matrix.
! Sums, differences and products of matrices are defined using ordinary arithmetic
! operations +,- and *. Arithmetic operations can combine scalars and matrices in the normal way.
! Now all matrices are in double precision. 

! The arithemetic operations work for matrices as follows for arguments ]a1[ and ]a2[
! \begin{itemize}
! \item ]a1[ + ]a2[
! \begin{itemize}
 ! \item ]a1[ and ]a2[ can be compatibe matrices 
! \item ]a1[ or ]a2[ can be scalar (REAL) and the other argument is MATRIX.
! \item ]a1[ or ]a2[ can be row vector and the other argument 
! can be matrix having the same number 
! of columns. Then the row vector is added to each row of the matrix. This is NONSTADARD.
 ! Similarly the other argument can be a colun vector and the other argument matrix having the same number of rows.
 ! Then the vector is added to each column of the matrix. NONSTANDARD.
! \end{itemize}
 
! \end{itemize}

! The same computation rules apply for operations -, *. (elementwise product), and
! /. (elemetwise division). The same rules apply also for logical operations, 
! except the nonstandard rules do not apply.

! For multiplication ]a1[ * ]a2[, either of the arguments can be scalar,
 ! and the other matrix or LIST of REAL objects.
! When ]a1[ and ]a2[ are matrices, standar matrix multiplication rules apply.

! When ]a1[ or ]a2[ is LIST of REAL values then, it works exacty as
 ! a column vector, when it is on the input side.  The elements are eqaul 
 ! to the values of the REAL elements. When a LIST is an output of matrix 
 ! computaions, the an error occurs if the output of the matrix operation is
 ! not comaptibel with the number of elemets in the LIST.


!endheader
! Ex matrixop Matrix operations
! A=matrix(3,4,do->);
! A+2;
! A-1;
! 2*A;
! A*.matrix(3,4,do->2);
! A/.A;
! b=matrix(4,values->(1,3,6,8));
! A*b;
!Continue=1  !Error
! A*.b;  
! A+b(1,-3);  ! NONSTANDARD
! B=matrix(3,4,values->2);
!A;
! A.eq.B;
! li=list(x1...x3)
! li=4,5,7;
!A+li;
! li=matrix(3,do->);
! @li;
! A+li;
! b*A;
! A+t(b);
! li=matrix(4,do->);
! Continue=0
! endex
!endsection

! Section transcont Transformation control structures
! Within Jlp22 transformations, there can be similar controls structures as in the input programming. 
! The  difference  is  that  these  will  remain  as  part  of  the  transformation  set.  Only  the 
! 'if()output=...'structure is allowed at the command level, other are possible only within a 
! transformations set.
! endsection


! Section if if()

! if()j\_statement... \newline
! The one line if-statement. 
! endsection

! Section ifthen  if() elseif() else endif
! There can be 4 nested if()then structures. If-then-structures are not 
! allowed at command level.
! endheader

! Ex2
! if()then
! ....
! elseif()then
! ...
! else
! ....
! endif
! endex2
! endsection
!Section loops Loops and control strucures
!This section describes nonstadard functions.
!endsection


! Section do do() loops

! The loop construction in Jlp22 looks as follows: 
! endheader
! Ex2
! do(i,start,end[,step])
! enddo
! endex2
! Note cycle and exit are implemented in the current Jlp22 version with goto()
! Within a do–loop there can be cycleand exitdostatements 
!endnote
! Note There can be 8 nested loops. do-loop is not allowed at command level.
!endnote
! Ex doex do-loop
!!!begin
 ! transa=trans()
 ! do(i,1,5)
 !i;
! ad1: if(i.eq.3)goto(cycle)
 ! i;
 ! if(i.eq.4)goto(jump)
 ! cycle:enddo
 ! jump:i;
 ! !goto(ad1)  ! it is not allowed to jump into a loop
 ! /
 ! call(transa)
! endex
! endsection

! Section return return
! Return from a transformation set to the transformation object where call()
! function was, or  to the include file with call(), or to the sit> promt, 
! is call() was at sit>. 
! endheader
! Ex retex example of return and goto ()
! transa=trans()
! ad1:r=ran();
!if(r.lt.0.2)return
! goto(ad1)
! /
! call(transa)
! endex
! Note return is automatically put to the end of transformation object.
! endnote
! Note Labels in a transformation object are without ';' as the labels in an include file start with ';'.
! endnote

! endsection

! Section errexit errexit() returns to sit>
! Function errexit() returns the control to sit> prompt with a message similarly 
! as when an error occurs.
! endheader

! Ex errexitex errexit() returns as if error had occured
! transa=trans()
! if(a.eq.0)errexit('illegal value ',a)
! s=3/a; ! division with zero is tested automatically
! /
! a=3.7
! call(transa)
! transa(s); !tr can also be used as a function
! a=0
!Continue=1  !Do not stop in this selfmade error
! call(transa)
!Continue=0
! endex
! endsection


!Section goto goto() goto a label in TRANS
! Control can be transfered to a label in a transformation set with goto().
! There are two types of goto's, unconditional goto to a given label and goto 
! to an label from a group af labels based on a condition (Computed goto in Fortran).
! These are decribed in separate subsections. Notes common to both are presented here.
! endheader
! Note  It is not recommended to use goto() according to modern computation practices.  
! However, it was easier to implement cycle and exitdo with goto(). 
!endnote
! Note It is not allowed to jump in to a loop or into if -then structure. This is 
! checked already in in the parser. DOES NOT WORK NOW, WILL BE CORRECTED
! endnote
! Note Even if the labels are
! logically character arguments, they are not treated using CHARs. The parser
! handles them otherwise.
! endnote
! Note The label lines can contain code but the labels can stand on the line also alone.
! endnote
!endsection

!Section goto1 goto(label) Unconditional goto 
!An unconditional goto() has only one label argument.
!endheader
! Ex gotoex Example of unconditional goto
! transa=trans() 
! i=0 
! if(i.eq.0)goto(koe)
!out=99;
! koe:out=88;
! /
! call(transa)
!out;
! endex
!endsection

!Section goto2 goto(index,lable1...labeln) Conditional goto
!An conditional goto() selects the label from a group of labels.
!endheader
! Ex congotoex
! transa=trans()
! out=999
! goto(ad1)
! 77;
! ad1:
! 1;
! goto(2,ad1,ad3)
! 88;
! ad2:
! 2;
! goto(go,ad1,ad3)
! out=0;
! return
! ad3:
! 3;
! goto(3,ad3,ad1,ad2)
! /
! go=0  ! This determines the last goto
! call(transa)
! out;
! go=4
! ** Now error occurs
! Continue=1
! call(transa)
! Continue=0
! ;return
!endex
!Note A simulator for generating treatment schedules for forest stands 
! can be nicely defined using the conditional goto, as will shortly be described.
!endnote
!endsection





! Section ASSIGN  ]output[=]input[
! There are two assignment functions generated by '=', when the line is of
! form ]output[=func[]input[), then the output is directly 
! put to the output position of the function
! without explicitly generating assignment.
! When the codeline is in form ]output[=]input[ then the following cases can occur

! \begin{itemize}
! \item  ]output[ is MATRIX  
! and ]input[ is scalar, then each element of MATRIX is replaced with the ]input[ 
! in assone() function.
! \item  ]output[ is submatrix expression, then the elements of the
! submatrix are asigned in setelem() funtion whether ]input[ is MATRIX or submatrix 
! expression, scalar or LIST.

! \item  ]output[ is MATRIX  and on input side is a random number 
! generation function, the random numbers are put to all elements of the matrix.

! \item If on output side are many object names, and input side is
! one REAL value, this is put to all variables.

! \item If on output side are many object names, and input there are several
! variables then both sides should have equal numbers of object names, then
! then copies of the input objects are put into output objects. 


! \end{itemize}
! endheader
! Ex assignex Examples of assignments 
! a=matrix(2,3);
! a=4;
! a=rann();
! v1...v5=2...6;
! v1...v5=77;
! Continue=1  ! ERROR
! v1..v3=1,5;
! v1..3=1...3   ! v is missing from the front of 3
! Continue=0
!endex
! endsection




a call to function assone()




!Section randomgen Random number generators
!Random number generators are taken from Ranlib library of Netlib. 
!They can produce single REAL variables or random MATRIX objects.
!Random matrices are produced by defining first a matrix with matrix()
!funtion and putting that as the output.
!endheader
!endsection

! Section Plotting Plotting figures
! The graphiscs of the current version of Jlp22 is produced with gnuplot, see
!\url{http://www.overleaf.com}
! Jlp22 offers an alternative interface
! to gnuplot, and it is quite easy to add more ploting routines later.
! endsection
! Section figu Figures 
! Figures are made using gnuplot, see \url{http://gnuplot.info}. Jlp22 transmits information into gnuplot using text files.
! Jlp22 generates the files using .jfig extension. Necessary files are generated  by deleting old
! files without asking permission. If ]fig[ is the output of a figure function, then
! Jlp22 creates always, except in 3D, file with name ]fig[.jfig and possibly other files with
! .jfi0, jfi1  etc extensions.


! Graphic functions produce FIG objects, except plot3d() which is plotting 3-d figures 
! without FIG. Each FIG can consist of 
! several subfigures. Each FIG  stores information of x- and y axes, the 
! range of all x- and y-values, and for each sub-figure information of the ranges 
! of x and y in the subfigure plus the subfigure type and the needed data values. 

!Graphics functions which produce small number of points 
! store the points in the ]fig[.jfig file. Large number of points produced e.g. plotyx() are 
!placed into different files.
!endsection

!Section show show(), show->  and continue->
!By default, plotting functions plots (shows) FIGs immediately. When the final figure
!consists of several subfigures, it is convenient to prevent plotting using show->0.
! In developing scripts, it is convenient to switch with show->. This can be done by giving
! option in form show->showfig, then the ploting can be controlled with REAL showfig.

!Withing show() it is possible to define or redefine xlabel->, ylabel->,title->,
!xrange-> and yrange->

!By default Jlp22 generates pause() after showing a FIG. During pause(), the user can give
! any commands. If the user types 'e', then Jlp22 generates a error condition causing return to
!to sit>.


! It is possible to collect a FIG first (e.g. using loops), and 
! show then the FIG using show() function. The argument of show() can be
!  either a FIG or the name of the .jfig file withing apostrohes.
 ! Thus it is possible
 ! to edit the file using gnuplot capabilities.
 !endheader
 
 ! Ex showex Example of show()
	! fi=draw(func->sqrt2(x),x->x,xrange->(-50,50),continue->fcont)
	! show(fi,xrange->(-60,60),xlabel->'NEWX]Times Roman,16[',ylabel->'NEWY]Courier,10[',continue->fcont)
	! show(fi,axes->10,continue->fcont)
	! show(fi,axes->01,continue->fcont)
	! show(fi,axes->00,continue->fcont)
	! Window='400,800'
	! show(fi,continue->fcont)
	! Window='700,700'
	! fi=drawline(1,10,3,1,color->Red,continue->fcont)
	!*** The line is not visible
	! show(fi,xrange->(1.1,11),continue->fcont)
	! dat=data(read->(x,y),in->)
	! 1,4
	! 2,6
	! 3,2
	! 5,1
	! /
	! stat()
	! *** gnuplot hides points at border
	! fi=plotyx(y,x,continue->fcont)  
	! ** The ranges needs to be adjusted manually 
	! show(fi,xrange->(0,6),yrange->(0,7),continue->fcont)
 
	! endex
 
 !endsection
 !Section axes axes-> tells what axes are drawn
 ! axes-> option works as follows
! \begin{itemize}
! \item axes->11 Both axes are drawn. (Default)
! \item axes->10 x- axes is  drawn, y-axes not. 
! \item axes->01 x- axes is  drawn, y-axes not. ~ axes->1.
! \item axes->00 Neiher axes is drawn.
!\end{itemize}
!endheader
!Note The argument of axes-> is REAL, thus axes->01 is equivalent to axes->1 and 
!axes->00 is equivalent to axes->, but the using 01 and 00 is easier to understand.
!endnote
!endsection

 
!Section terminal Terminal
! It is possible to change the terminal type used by gnuplot by giving 
 ! the name of the terminal to the predefine CHAR variable ]Terminal[.
 ! The default is \newline ]Terminal[='qt'. 
 !endsection
 
 !Section window Window size and shape
! It is possible to change the window size and shape of gnuplot by 
! using the predefined CHAR variable Window.
! The default is \newline
! Window='700,700'
!endsection

!Section color color->]Black[, ]Red[, ]Green[, ]Blue[, ]Cyan[ , ]Violet[, ]Yellow[, ]Orange[
!gnuplot allows arbitrary color definitions. Currently the above colors can be used.
!General color definitions are implemented  when requested.
!endsection


!Section legend Legends
!\item The default legends by gnuplot do not look nice, and they are not implemented.
! The user can write own legends using label-> option in drawline().
!endsection

!Section font Font in title->, xlabel->, ylabel->, label->
!It is possible to change the the font by appending the the font defintion 
! between ][ at the end of the label, e.g., \\
!xlabel->'My-xlabel]Times-Roman,15['\\
!where 15 is the size of the font. Available fonts vary from system to system. Web provides further inforamtion, see e.g
!\url{https://gnuplot.sourceforge.net/docs_4.2/node356.html}\\
!According to this page, the following fonts may be available
! Helvetica	 
 	! Helvetica Bold	 
 	! Helvetica Oblique	 
 	! Helvetica Bold Oblique	 \\
 	! Times Roman	 
 	! Times Bold	 
 	! Times Italic	 
 	! Times Bold Italic	 \\
 	! Courier	 
 	! Courier Bold	 
 	! Courier Oblique	 
 	! Courier Bold Oblique	 \\
 	! Symbol	 \\
 	! Hershey/Cartographic_Roman	 
 	! Hershey/Cartographic_Greek	 
 	! Hershey/Simplex_Roman	 
 	! Hershey/Simplex_Greek	 
 	! Hershey/Simplex_Script	\\ 
 	! Hershey/Complex_Roman	 
 	! Hershey/Complex_Greek	 
 	! Hershey/Complex_Script	 
 	! Hershey/Complex_Italic	 
 	! Hershey/Complex_Cyrillic	 
 	! Hershey/Duplex_Roman	 
 	! Hershey/Triplex_Roman	 
 	! Hershey/Triplex_Italic	\\ 
 	! Hershey/Gothic_German	 
 	! Hershey/Gothic_English	 
 	! Hershey/Gothic_Italian	 
 	! Hershey/Symbol_Set_1	 
 	! Hershey/Symbol_Set_2	 
 	! Hershey/Symbol_Math	 \\
 	! ZapfDingbats.
!space within font name can be replaced with '-', e.g. Times-Roman.	
 !endsection
 
 !Section gnuchar Scandic and other special characters
 ! Scandic charcters can be put into figures as follows. Make first the figure
 !without scandic characters e.g using characters without the dots. Let the name of the generated FIG object be fig. 
 !Open the file fig.jfig. Change the coding of the file into UTF-8 (under Encoding in Notepad++).
 !Add the scandic characters to xlabel, ylabel, title, or label -parts in the header.
 !Save the file. Give at sit> prompt the command show('fig.jfig').\\
 !Subscript is made with the underscore before the subscript.\\
 !Underscore is put into the labels with three backslash followed with the the underscore.\\
 !Superscript is made with ^ before the character.\\
 !Character ^ can be put into the text with three backslash followed with ^.\\
 !Longer subscripts or superscripts can be made using {} around the scripts.\\
 !For other things see gnuplot documentation.
 !endsection
 


!Section joperation Operation of Jlp22
!In this section the main structure of the operation of Jlp22 and tools
! in code development in a project are presented.
!The two operation modes are interactive operation and batch operation.
!endsection

! Section basicloop Looping between j\_getinput, j\_parser and dotrans
! The are three key subroutines in Jlp22 operation.
! \begin{itemize}
! \item j\_getinput gets a new command line from the console, an include file. j\_getinput can 
! read several records to make one command line, and it can edit or duplicate the input
! with special \textbf{input programming} tools. Jlp prints sit> prompt
 ! when reading form the console. Input programming lines are indicated with initila \%.
! \item If the obtained input line is not an input programming command or if it is not 
! captured by some function which is utilizing j\_getinput, the line goes to j\_parser which
! generates an integer vector.
! \item The integer vector produced by the j_parser is interpred ('executed' in this manual)
! with dotrans subroutine.
! \item trans() function packs several lines generated in j\_getinput - j \_parser loops
! into a tranformation (TRANS) object, which can be called from different functions.
! \item dotrans subroutine executes a single line command which is not part of an TRANS object.
! Jlp22 writes '#' in te front of the line.
! \end{itemize}
! endsection

!Section printing Printing of Jlp22
!Jlp22 prints information of the proceeding of the control. There are different ways to control
! the output. Finetuning is needed in the output. There are three logical 
!stages in the flow of the control. The output indicates these as follows.
!endsection

!Section printinpu % -lines are printed from input programming
! The input programming lines are printed starting with %. 
! The amount of printing is controlled with ]Printinput[ variable. 
! the dafault is Printinput=1. A problem in printing the input is how much should be
!printed when many input lines are produced with ;do()
!endsection

!Section printcommand # -lines are printed in one-line commands.
! The input lines which go directly to execution are printed starting with #.
!endsection

!Section printcom Comments starting with !!, !*,** or *! are printed
! The first non blank character in a command line is '!' or '*'.
!If there are two consecutive comment characters, the line is printed, dropping the first
!character.
!endheader
!Note There can be comment lines between continuation lines.
!endnote
!endsection

!Section printoutput ]Printoutput[ guides printing of functions.
! The amount of printing in functions is guided with with variable [Printoutput[.
!The default is \\
![Printoutput[=2\\
!Several functions have print-> option which overrules ]Printoutput[
! The number of printed lines when printing MATRIX,TEXT, or TXT is controlled with 
!variable ]Maxlines[, which is overruled with maxlines option in some functions.
!endsection


!Section interactive Interactive operation
! In the interactive operation, Jlp22 may first read commands from the
! default ;incl -file or from the file specified when starting the software,e.g. using\\
! Jlp22 myincl.inc \\
! or with the release version
! Jlp22r myinc.inc\\
! where myinc.inc is the file giving the initial commands. If command 'end' is read, then the program exites.
! But after reading an ;incl-file to the end or up to ;return, or after encountering an error, the Jlp22 starts
! to read commands from the console using 'sit>' -prompt, where the user can give 
! operation commands or new ;incl -command or 'end'.

!In the interactive operation, the processing of sripts can be interrupted with ;pause, and
! execution of TRANS can be intterrupted with pause(). Even if they are described in 
! 'Command input and output' and 'Jlp22 transformations' chapters, descriptions 
! are repeated here as they are useful in the interactive operation of Jlp22.
!endsection

!Section batch Batch mode 
!If the default main program is replaced with a program which tells that Jlp is operated 
! in the batch mode, or if the initial   ;incl -file containscommand batch(), the Jlp22 is operated in
! the batch mode. In the batch mode, the control never starts to read commands from the 
! console at sit> prompt. Using Jlp22 from R, developed with Lauri Meht\"atalo is using Jlp22 in the batch mode.
!endsection

!Section operation2 Using shortcuts and sections in ;incl files

!It is useful to organize
! the project sript into one script file, which conatians swections starting with a lable and ending
! with ;return. 
! I think that it is more difficult to have several script files.
 ! The example file jexamples.inc is a good example of a script file.
! !The script files should start with shortcuts for each section. If it is possible that 
! different versions of the same script file are stored in different names, it is useful to have
 ! as first line something like
 ! this=thisfile()\\
 ! Then it is not necessary to change anything if the file is stored in a different name.
 ! Thereafter comes the shortcut definitions for different sections.
 ! the same 
! For instance, if the section
! label is \\
! ;thistask:\\
! then the shortcut definition could be
! thistaskh=';incl(this,from->thistask)'\\

! The section should end with\\
! ;return\\
! After defining shortcuts for all sections, it is useful to have a shortcut as:\\
! again=;incl(this)\\
! If new sections are added, then one needs to give just shortcut\\
! again\\
! and then the new shortcuts will be defined. It does not matter if the earlier shortcuts are redefined. 

! The last shortcut could be \\
! current=';incl(this,from->current)
! The label 'current' can be a floating label which is put into the section which is under developed
! in place the problems started.

! If a Jlp22 code line, either in the input paragraph defining a transformation object
 ! or outside it, ends with ';' or ';;', the output object of the code line may be printed.
! The output of ';'-line is printed if the variable ]Printoutput[ has value 1 or 3 at the time when the
 ! code line is computed.
 ! The output of ';;'-line is printed if the variable ]Printoutput[ has value 2 or 3 at the time when the
 ! code line is computed.
 
 ! If a code line within a tranformation has function pause('text'), then a pause is generated during which
 ! the user can give any commands except
 ! input programming commands. If the user will press <return> then the exceution continues. If the user
 ! presses 'e' and <return>, the control comes to the sit> promt similarly as during an error.
 
 ! If the line outside the transformation definition paragraph is ';pause', then
 ! a similar pause is generated except also input programming commands can be give.
 
 ! If the variable ]Debugtrans[ has value 1, them a pause() is genertated before each line within
! a tranformation object is executed.  If variable ]Debugconsole[ has value 1, 
! a ';pause' is generated before  the line is excuted. In bot cases the user can
 ! give new values for ]Debugtrans[ and ]Debugconsole[.
 
 ! What happens when an error is encountered is dependent on the value of variable ]Continue[. If ]Continue[ has
 ! value 0 (the default case), the control comes into sit> prompt when an real error occurs or if an atrficial 
 ! error condition is generated with errexit(). If ]Continue[ has value 1 then the computation continues in
 ! the same script file where the error occured. This property is used in file jexamples.inc to demonstrate 
 ! possible error conditions so that the computation continues as if no error had occured.

 
 !endsection



!ote Using ;incl() in a project
!When working in a project it is reasonable to organize
!the include file as follows. Put into the beginning of the file section:\\
!this=thisfile()  !There can different versions of the file with differetn names.\\
!A=';incl(this)' !If new sections are added to the file, new shortcuts
!can be defined by adding those here and writing A at sit> prompt.\\
!R=';incl(this,from->read)'     ! read data in \\
!T1=';incl(this,from->task1)'   ! first analysis \\
!T2=';incl(this,from->task2)'   ! second analysis \\
!;return \\
!Now everything what needs to written at sit> after the first
!;incl() are the shortcuts. If adding section task3 then
!add the shortcut here, then write shortcuts A and T3 at sit>.
!The file jexamples.inc which comes with the manual and which is generated
! with the jmanual program shows an examle.



!Section own o1_funcs(), o2_funcs() and o3_funcs() calls own functions
! The users of open Jlp22 can define their own functions using three
! available own-function sets. In addition to own functions open Jlp22 is ready to
! recognize also own object types and options which are defined in the source files
! controlled by the users. The main Jlp22 does not know what to do with these own 
! object types and options, they are just transmitted to the own-functions.
! In the main Jlp22 the control is transmitted to the own functions using implicit
! Jlp22 functions o1_funcs(), o2_funcs() and o3_funcs().
! endsection

!Section arit Arithmetic and logical operations
! !The arithmetic and logical operations are first converted into the polish notation.
! The logical operations follow the same ruels as addition +. The following rules, 
! extending the standard matrix computaion rules apply. The same rules aplly if the
 ! order of arguments is changed,
! \begin{itemize}
! \item MATRIX + REAL : REAL is added to each element

! \item MATRIX1+MATRIX2 :: elementwise addition, if matrices hav comptaible dimensions
! \item  MATRIX+ column vector: column vector is added to each column of MATRIX 
! if the numbers of rows agrees.
! \item  MATRIX+ row vector: row vector is added to each 
! row of MATRIX 
! if the numbers of columns agree.

! \end{itemize}
! The same rules apply for the lelmentwise multiplication *. and elementwise
! division /. as for addition +.
! endsection


! Section minmax min() and max()
! Functions min() and max ()
 ! behave in a special way, max() behaves similarly as min() here:
 ! \begin{itemize}
 ! \item min(x1,x2):: minimum of two REAL
 ! \item min(MATRIX,REAL):: each element is min(elem,REAL)
 ! \item min(MATRIX):: row vector having minimums of all columns
 ! \item min(MATRIX,any->):: minimum over the whole amtrix
 ! \end{itemize}
 ! endsection
 
 ! Section Special Special arithmetic functions
 ! Jlp22 has the following arithmetic functions producing REAL values.These functions cannot yet have
 !matrix arguments.
 ! endsection
 
 ! Section dist Probality distributions
 ! There are currently the following functions relate to probability distributions.
 !endheader
 ! Note function density() can be used define density or probability 
 ! function for any continuous or discrete distribution which can then be used 
 ! to generate random numbers with random() function.
 ! endnote
 ! endsection
 
 ! Section inter Interpolation
 ! The following functions can be used for interpolation
 ! endsection
 
 ! Section lists List functions
 ! The following list functions are available
 ! endsection
 
 !Section JR Co-operation between Jlp22 and R
 !Is is possible to run R scripst from Jlp22 and Jlp22 scripts from R. 
!endsection

!Section  Rcalls Calling Jlp22-scripts from R
! File JR\_0.0.tar.gz in the folder J\_R contains R tarball for taking Jlp22  subroutines into R.
! With R command JR(”testr.inc”) the example jp problem can be solved from R.
! Later lauri Mehtat\"alo will develop this co-operation further so that R can directly access also 
! matrices in the Jlp22 memory.
!For further information contact lauri.mehtatalo@luke.fi
! THIS DOES NOT WORK NOW We will reconsider it soon with Lauri
!endsection

! Section texts TEXT and TXT text objects 
! The are now two object types for text.
! endsection

! Section file File handling
! The following functions can handle files.
! endsection

!Section showdir showdir() shows the current directory
!endheader
!Note showdir is defined in the system dependent file jsysdep\_gfortran.f90.
!Using other compliers it may be neccessary to change the definition
!endnote
!endsection

!Section setdir setdir() sets the current directory
!endheader
!Note setdir is defined in the system dependent file jsysdep\_gfortran.f90.
!Using other complilers it may be neccessary to change the definition
!endnote
!endsection

! Section io Io-functions
! Theree are following io functions
! endsection


!Section matrixs Matrix functions
!Jlp22 contains now the following matrix functions.
!endsection



! Section jlpintro Linear programming (JLP) functions
! There are linear programming functions for defining and solving ordinary LP-problems or
! LP problems found in forest management planning.
! endsection



! Section spline Splines, stem splines,  and volume functions
! There are several spline functions.
!endsection

!Section bit Bit functions
! bit functions help to store large amount of binary variables in small space. 
! These functions are used in domain calculations
! endsection

!Section misc Misc. functions
! There are some functions which do not belong to previous classes.
! endsection

! Section jbib LATEX
! endheader
! Latex 
! \begin{thebibliography}{9}

! \bibitem{dan}
   !  Dantzig, G.B. and VanSlyke, R.M.  (1967)
    ! \emph{Generalized upper bounding techniques}
    ! J Compt Sys Sci 1(10),213-226
				
 ! \bibitem{flet}Fletcher,R.  1996. Dense factors of Sparse matrices. Dundee
 ! Numerical Analysis Report NA/170.
 
  
! \bibitem{howard} 
   ! Hoganson, H.M. and Rose, D.W.  (1984),
    ! \emph{A simulation approach for optimal timber management scheduling}
   ! Forest Science, 30:220-238
	  
 ! \bibitem{dtran}Hoganson, H.M. and Kapple,  D.C. (1991),
    ! \emph{DTRAN version 1.0. A multi-market timber supply model. Users’ guide}
   ! Minneapolis: University of Minnesota Department of Forest
! Resources Staff Series Paper 82,

! \bibitem{pekka}
!  Hyv\"onen, Pekka, Lempinen, Reetta,  
		! Lappi, Juha, Laitila, Juha  and Packalen, Tuula (2019)
   ! \emph{Joining up optimisation of wood supply chains with forest},
    ! Forestry an international journal of forestry,
    ! 93(1):163--177,
    ! DOI = https://doi.org/10.1093/forestry/cpz058
	
 ! \bibitem{JLP} Lappi, Juha (1992) \emph{JLP -- a linear programming package for
! management planning} Finnish Forest Research Institute
! Research papers; 414, 134 p.
  
 
 
 ! \bibitem{LL}
    !Lappi, Juha and Lempinen, Reetta (2014)
    ! \emph{A linear programming algorithm and software 
		! for forest-level planning problems
   ! including factories}
    ! Scandinavian Journal of Forest Research,29 Supplement 178--184",
   ! DOI =  http://dx.doi.org/10.1080/02827581.2014.886714
 
 ! \bibitem{gnu}
! Thomas Williams, Thomas and Kelley, Colin (2022),
  ! \emph{gnuplot 5.5},
  ! url = http://gnuplot.info/docs_5.5/


 
 

    
! \end{thebibliography}
! endlatex
! endsection

! Section future Future development
!The previous version contained possibilities to include factories into the optimization.
! Factory optimization is not available in the current version, because I'm now 
! building a completely new version. I have already cleaned the data structures
! of linear programming
! and put the algorithm into reasonable subroutines. This makes it possible to
! follow and optimized the
! the flow of control. This made it already possible to put ordinary linear programming
!into a separate jlpz() function.

! I think that the current version of Jlp22 provides many possibilities for future developments.
! For instance:
! \begin{itemize}
! \itemThe current version does not have any special functions 
! for making simulators. The new goto() commands, possibility to work with submatrices, 
! and the new transdata() function provide much more efficient ways to develop simulators.
! Examples will be provided shortly.
! \item Using the possibility to compute derivatives using the analytic derivates makes it quite straightforward
! to make it possible to have a nonlinear objective function and nonlinear constraints. These things
! are under design.
!\item It would be quite easy to include tools for piecewise linear constraints
!and objectives.
! \item It would be quite easy to develop Jlp22 so that integer solution is produced with respect to the 
! schedule weight.
! \item It would be interesting to see how Jlp22 can put to work with Heureka.
! \item The possibility to run R scripts from Jlp22 and Jlp22 scripts from R provide new possibilities.
! \item Jlp22 can now be used as an interface to gnuplot. 
! Google search show how many possibilities gnuplot provides.
! It is quite straightforward to implement these graphs if it is not currently possible.
! \item The possibility to generate random numbers from any discrete or continuous distribution provide new 
! possibilities to study the effects of random errors in the optimization.
! \item The new tools for analyzing grouped data are useful when studying the grouped data. it would
! be straightforward to implement mixed model methods based on expected means squares.
! \end{itemize}
! endsection

!Section LP Linear programming
! This chapter decribes the key points  of the Jlp-algoritm and the available 
! Jlp22 functions. 
!endsection


! Section JLPalgo JLP linear programming algorithm 
! This section will later describe more closely the theoretical aspects of the linear programming
! functions. Now only some key concepts are listed. Now the reader is referred to the old
! JLP manual \href{run:./jlp92.pdf}{jlp92.pdf}, the description of the factory optimization in
!\href{run:./lappilempinen.pdf}{lappilempinen.pdf}, and an application of the factory optimization in 
! \href{run:./hyvonenetal2019.pdf}{hyvonenetal2019.pdf}

! The development of JLP algorithm
!
! \begin{itemize}
 !\item JLP

! \begin{itemize}
!\item The JLP algorithm was designed for forest management planning problems having the following structure.
! A simulator generates a large number of treatment schedules
 ! for each stand in a group of stands. 
 !\item In an optimization problem a linear combination of sums of
  ! variables (e.g. amount of harvested sawlogs during a period) produced in treatments is maximized or minimized subject to constraints which are also
	! linear combinations of variables.
	
! \item The key point is 
! the generalized upper bound (GUB) technique of Dantzik and Van Slyke (see \href{run:./gub.pdf}{gub.pdf})
! which I reinvented. The key idea is to remove with algebraic tricks 
! the area constraints. 

! \item In a optimization problem with schedules generated for each stand, there must be a area 
! constraint for each stand telling that shares of schedules add up to one in each stand.
! \item In the GUB technique, the area contraints can
! be dropped with slight overhead cost. In a typical problem,the data can consist of 10000 stands, and and 
! optimization problem can consist of 10 contraints for the sums ofe variables. Using an ordinary LP software 
! in one iterative optimization step, a matrix consisting of 100200100 elements is updated. 
!In JLP the equivalent 
! step is computed by updating a matrix consisting 100 elements.

! \item The heuristic algorithm of Hoganson and Rose (1984) and 
! Hoganson and Kapple (1991) leads to similar computations where a schedule
 ! in  a stand is selected using shadow prices. Their shadow prices are updated heuritically but 
 ! JLP algorith updates the prices using the linear programming theory.
 
 ! \item The key concept in GUB is the key variable, in our case the key schedule, which is
 ! any of the schedules which has nonzero weight.
 
! \item JLP algorithm is also using the ordinary upper bound technique. If there is both
! lower and upper bound in a contraint, the standard theory assumes that the lower bound and upper bound
! constraints are presented  as different constraints. In the ordinary upper bound technique there
! is only one constraint, and the algorithm keeps either of the bounds as the active bound.
! \item JLP used own matrix subroutines which computed all the time the explicit inverse
! of the basis matrix. 
 !\item When a constraint is not binding, in standard algorithms, a residual variable tells 
! the difference between the contraint row and the active bound. JLP reduced the dimension of the basis matrix,
!which was a feasible solution because the explicit inverse of the basis was used.
! \item JLP  introduced domains, i.e.. subsets of stands into the problem
! defition. They decrease the memory needs and help to formulate more reasonable problems.
! Their utility to define spatial constraints is not fully utilized.
! \item JLP allowed to compute new variables from the simulated variables. 
! I have suggested (in vain) since 1992 that Mela would compute only forest variables and economic variables
! would be feeded in JLP. This way it would not be necessary to resimulate when trying different prices.
!\item JLP offered the possibility to duplicate a schdedule. GAYA group has utilized this by duplicating a schdeule so tha that
! in one copy of a no-harvest schedule the final stae has postive net presetn value and anothe copy does not.
!\item JLP was written in Fortran77, which did not have
! dynamic allocation, pointers or own data types.
! \item In writing the JLP algorithm, oaly very small part of the working time went to get the algorithm work correctly
! mathematically. The most difficult thing was the fight against rounding errors, i.e. trying to infer whther a small
!number is zero or not, and whether a number is really larger than another number even if the computer values indicated that.
!\item JLP had a precompiler which could be used to handle compiler options and the sizes of vectors.
!Fortran77 did not have dynamic alloacation of vectors.
! \end{itemize}
! \item J, the successor for JLP
! \begin{itemize}
! \item Version 0.9.3 was published in 2004
! \item Initially the same JLP algorithm but J was using matrix routines of Fletcher which were changed into
! double precision. Flethcer's code was written in Fortran77.
! \item J was written in Fortran90 which has dynamic allocation of vectors, pointers etc.
! \item New tools 
	! for preprocessing of data and postprocessing of results, and these computations
! can be used  also without LP problems.
!\item Mela has not
 ! included J as
 ! as the optimizer, but it is possible to pull out simulated schedules from Mela and then
 ! define and solve linear programming problems using J. 
!item  J version 2.0. published in 2013 made it possible optimize simultatenously
 ! forestry and transportations to factories
 ! and factory production. Theory is published in \href{run:./lappilempinen.pdf}{Lappi and Lempinen 2014} \hspace{0.2cm} Paper explaining the theory behing factory optimization.
!\item The generalized upper bound tehcnique is extended 
 ! for constraints which tell that
 ! all harvested timber volume in a stand is transported somewhere. 
 !\item The key idea is to have in each stand and for all harvested log types and for all periods a key factory to which some timber is tranported
 ! provided that the cuttings produce that log type for that period.
!end{itemize}
!\item  DTRAN algoritm of Hoganson is an competitor of Jlp22 because it can deal with
! factories also.
!
! \end{itemize}
!endsection

!Section error Error handling
!There can happen basically three kinds of errors:
!endsection

! Section errortype Error types
! \begin{itemize}
! \item The user makes an error an Jlp22 detects the error, writes the proper error message
! and returns the control to the sit> prompt in the console, if variable Continue has value zero. If Continue has a nonzero value
! Jlp22 continues one level above the console.

! The user makes an error, but Jlp22 does not recognize this. As Jlp22 should recognize all errors the
! user can make, this case is thus also a programming deficiency.
! In this case Jlp22 
! behaves similarly as in the following case.

! \item The error is a programming error in Jlp22. Then two cases can happen:
! \begin{itemize}
! \item Jlp22 does not recognize that something is in error, and the system crashes. The debug
! version writes then more information than the release version. It is important that Jlp22 is
! used in the commend prompt, so that it does not just disappear.
! \item Jlp22 recognizes in lower level subroutines that something is wrong, but the 
! lower level subroutine does not know waht is the reason. Thwe Jlp22 prints an error message
! starting with *j*. Even if the user recognizes that she was guilty, thes cases should be reported
! so that detection of user errors can be improved.
! \end{itemize}
!\end{itemize}
!endsection

! Section errorhand Handling of errors
! There are two control layers, input programming and execution of one-line commands. Both can utilize
! the code obtained with parser, but input programming is utilizing the parser only a little.
! Jlp22 function can use TRANS objects containing packed parsed code in many different ways.
! There can be nesting both in input programming and executing TRANS objects. The ;incl files 
! can be nested up to 5 levels. Functions can be recursive in many different ways. A function can call itself
! through many routes. 

! In case of error should be able to tell for all nested ;incl files what line is 
! processed, and errors within TRANS objects should be able to tell through the calling sequence 
! which line is under execution.
! Let us test this in the following example.
! endheader

!Ex errorex
! round=5
! write('inca.txt',$,'**we are in inca.txt')
! write('inca.txt',$,'round;')
! write('inca.txt',$,';incl(incb.txt)')
! close('inca.txt')
! print_f('inca.txt')
! write('incb.txt',$,'**we are in incb.txt')
! write('incb.txt',$,'round;')
! write('incb.txt',$,'round=round-1;')
! write('incb.txt',$,'call(transa)')
! write('incb.txt',$,';incl(inca.txt)')
! close('incb.txt')
! print_f('incb.txt')
! transa=trans()
! c=4/round;
! /
! ** let us see what happens
! Continue=1
! ;incl(inca.txt)
! ** maximum ;incl nesting was obtained

! round=2
! ** what happens now?
! ;incl(inca.txt)
! Continue=0
! delete_f('inca.txt','incb.txt')
! endex
!endsection
